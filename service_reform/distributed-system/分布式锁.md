Distributed Lock
---
分布式锁，分布式场景下（有状态的中间件DB、MQ、Redis缓存、ES；无状态的但垂直拆分了多个的应用server 多实例），无状态的应用 如何解决并发访问 无分布式事务机制（无原子性、ACID保证）的中间件（如两个MySQL、一个redis上的缓存key） 的冲突（的一种同步机制）。
+ 电商场景，库存预设、超卖、秒杀
+ 用于注册，用户名字

分布式锁，保证多个应用同一时刻只有一个线程可以访问竞争资源（比如一个redis缓存key）。（类比 同一进程在操作系统的锁）

分布式锁最大的敌人NPC：
+ Network Delay，网络延迟，所有信息系统的外部不可抗力（局域网、同一机房内可忽略（运维不可忽略））
+ Process Pause，进程暂停（比如 GC时间、虚拟机Pause调度到其他机器？、同步磁盘IO。。。）
+ Clock Drift，时钟漂移（设备的本地时间可能突然向前、向后跳跃）
    + 现实中，时间平稳流逝、单调递增
    + 计算机中，硬件石英时钟精度有限，通常用NTP协议将本地时间与专门的时间服务器对齐。

系统环境复杂，各类问题都有可能导致锁失效，也即分布式锁无法解决正确性问题、实际是用于优化程序效率（correctness =》 efficiency），协调各个客户端避免作重复的工作。即使锁失效了，也只是把一些操作多做一遍、不会有其他后果，比如重复发送一封邮件？

例子，nonce token（或称 fencing token）上锁时生成一个单调递增数字返回，访问资源时提供该token、提供资源的服务可检查该token是否已处理过，拒绝掉延迟的访问请求。

+ 分布式锁（特指redis lock，暂时只能）只能解决性能优化问题，并不能解决正确性问题
+ 端到端的一致性问题，必须由资源层参与一致性判断，检查所持fencing token信息


+ 基于Redlock
+ ZK
+ 数据库

# redis lock
参考阅读：https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

Redis lock，分布式系统中的并发访问或修改同一资源（该资源本身没有锁机制（如多个MySQL实例并发冲突），或者锁的成本比较高（耗时大）），用于避免并发冲突。

还可用于：
+ 并发数据访问，避免冲突
    + 分布式缓存一致性，缓存更新、配置更新，避免被并发更新冲突 
+ 模拟分布式事务效果，分布式数据库操作（多个MySQL访问、多个MQ实例访问）
+ 防止缓存穿透和缓存击穿
    + 缓存穿透，同一个数据的缓存未命中的大量流量请求到数据库
    + 缓存击穿，同一个数据的缓存过期、大量流量并发查询数据并更新到缓存
    + 使用redis锁，限制只有一个请求区查询数据库，写入缓存

```sh
setnx key # set if not exist
set key value nx ex seconds
```

## redis锁的问题分析 
通过Lua脚本 或 Redission客户端来保证加锁、续期和解锁的原子性。
+ 加锁，setnx 和 ex过期时间的原子性
+ 续期，check 和 set的原子性
+ 解锁，check 和 del的原子性

+ 重试机制，避免无限等待，合理重试
    + time.sleep 和 time.ticker 都可以作时间等待。底层都是timer
    + 后者结合channel
+ 锁超时，业务执行过长或锁过期时间太短、redis连接异常或中断
    + redission watchdog来定时自动续期
    + 任务拆分，间隔续期
    + 定时任务 ticker 续期


+ 锁需要具备唯一性，ID标识同一个竞态数据或资源
+ 锁需要有超时时间，防止死锁
    + 锁过期了，业务还没有执行完？
    + 需要对业务做超时限制
        + 如果任务不可以再切割，超时后续期
        + 如果任务可以切割
            + 超时后退出当前执行
            + 超时后续接时间
+ 锁的创建和设置锁超时时间需要具备原子性
+ 锁的超时的续期问题
+ B的锁被A给释放了的问题
+ 锁的可重入问题，
+ 集群下分布式锁的问题

## 锁算法
redis lock/redlock/redission
+ NX，not exist set，如果不存在则设置、返回1，否则返回0。
    + key 为 竞争资源标识；value 为锁持有者标识（uid+随机数？uuid）；
    + 返回1 获得锁，继续执行，理想中执行完释放锁（del key）
    + 返回0 则设置超时时间（x秒），重试加锁
+ 进程会崩溃或被kill，所以必须设置超时时间（y秒） EX。
+ 超时时间可能会超时，所以需要续期。
+ 删除锁的时候，如果刚好 redis上锁过期了 又被下一个进程上锁了，就会发生锁被误删
    + 所以，删除需要（原子操作地）判断是当前进程持有的锁、删除

当前的redis机制并不能完全解决分布式锁的需求：
+ 业务逻辑耗时过长，超时一再续期（单例MySQL锁也会遇到，所以忽略）
+ 锁有效期5秒，加锁花费1秒

## 时间设置
+ 锁过期时间，预期执行时间的2倍，如10s
    + redission 默认有效期 30秒
    + 不应过短，防止时钟漂移，一次漂移差在3s以内
+ 锁的续期时间，锁过期时间的一半，如5s
    + redission watchdog的检查锁的超时时间默认为30s
+ 重试锁的间隔时间，根据并发量和锁竞争的激烈程度，越激烈越长，如200ms
    + 可根据需要调整，低并发可以缩短为100ms
+ 重试锁的次数，根据业务的重要程度和可容忍度来设置，默认10次
    + 

# ZooKeeper
+ 使用ZK的临时顺序节点
    + 在竞争资源下节点下（资源ID），增加当前业务的标识（UUID）
+ 会话结束，自动删除

+ 分布式一致性、更新原子性
+ 顺序执行
+ watcher机制，节点变更通知
    + 推拉结合的

优点
+ 强一致性
+ 高可靠，锁和会话生命周期同步和自动释放
+ 公平性，先请求的先获取到锁

缺点
+ 性能较低，多节点协调、网络通讯，不如基于缓存的实现
+ 实现负载，不易运维、监控


## zk分布式锁和redlock对比
+ zk是CP，redis是AP
    + redis 在某些情况（集群同步问题？主从切换、主节点故障）无法保证强一致性
+ 


# 其他

基于数据库锁，低并发场景。

+ ZK适用高一致性，如金融交易、分布式事务中的资源锁定、分布式资源调度
+ Redis适用 高并发高性能，如秒杀、抢购、缓存更新、分布式定时任务
+ 数据库锁，适用低并发，如配置更新
+ 