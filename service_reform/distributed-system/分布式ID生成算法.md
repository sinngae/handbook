# 分布式ID生成算法
目标：
+ 全局唯一，无重复
+ 递增，可以建立索引（分布式索引）
+ 高可用，ID生成是关键服务，压力大
+ 信息安全，暴漏在外？预防信息泄漏

+ uuid 128太长，太丑
+ 数据库简单有序，主从切换会重复发号，发号能力有限
+ zk性能不满足
+ redis自增ID，高性能，也有主从切换重复问题
+ snowflake

## uuid算法
机器网卡 + 本地时间 + 随机数

性能高，算法简易
本地生成，本地使用，不用网络传输
信息安全，无规律，可读性差

不易存储，128bit长度（32byte十六进制表示）
无序，不能生成业务需求的索引
(略)

## snowflake算法
`时间戳 + 机器标识 + 自增序列号`
+ 高性能，5w/s单节点
+ 全局整体递增
+ 灵活

**机器时钟回拨，ID重复问题**

### 实战
[39bit毫秒数][4bit业务线id][2bit机房id][7bit机器id][5bit预留][7bit毫秒内序号]  
每台服务器绝对递增，全局看只是趋势递增  
必然按msg-id/order-id/worker-id分库分表，取模运算要求ID生成具有“取模随机性",所以毫秒内序列号放最后，保证ID随机  
跨毫秒时，序号总是归0，序号尾为0的比较多，生成的ID取模不均匀，所以不是每次归零，而是归到0-9的随机数。

### snowflake算法
[1bit不用][41bit时间戳][10bit机器ID][12bit序列号]  
第一比特保留  
时间戳，41比特，从2016年11月1日零点到现在的毫秒数,可以用到2156年，100多年后才会用完  
机器id，10比特，这个机器id每个业务要唯一，机器id获取的策略后面会详述  
序列号，12比特，每台机器每毫秒最多产生4096个id，超过这个数的话会等到下一毫秒 
