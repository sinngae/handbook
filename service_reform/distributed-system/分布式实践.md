分布式实践
----
# 服务器崩溃实例
+ 人为操作失误，错误配置、误删关键数据、系统或个别程序缺陷
    + 操作规范、变更管理（变更对比）、双重验证（授权、执行、校验、确认）、定期备份
+ 硬件故障，硬盘掉线、多块硬盘先后掉线（超出RAID5冗余保护能力）、机房火灾？、
    + 数据备份、磁盘修复
+ 网络攻击，大规模流量攻击、分布式拒绝服务攻击
    + DDoS防护措施，流量清洗、黑洞路由
+ 软件问题，遍历大量小文件耗时过长，触发系统软锁机制
    + 文件系统操作耗时过长、锁竞争，需要优化、内核参数调整？
+ 资源过载，访问量激增（促销、秒杀）、流量超预期、
    + 缺少监控手段、资源分配不合理、
    + 自动扩展机制？


## soft lockup 软锁 是什么
panic还可以做尸检，软锁相当于植物人不知道会不会醒过来

+ 不是死循环、不是几行代码执行了几十秒
+ 是针对单独CPU而不是整个系统
+ 具体特征是发生的CPU上在20s（默认）中没有发生线程调度切换

具体的：
+ 死循环 且 禁止了内核抢占（比如软中断）
+ timer回调函数执行太久，导致软锁？
+ 频繁的spinlock、rwlock也会导致软锁？

情况总是有，及时重启、修复内核缺陷、驱动缺陷。


## 系统Oops
Linux内核 kernel panic会打印出Oops信息
+ 内存原因，段转换错误、页表错误（地址失效）、段/页权限错误、内存对齐错误
+ 中断异常导致bad_mode
+ 内核缺陷


## 资源过载为何服务中断？
+ 资源耗尽，
    + CPU过载、内存不足、磁盘IO瓶颈、网络IO瓶颈
    + CPU使用率不再随着请求量的上升，但是所有请求响应变慢
    + 缓冲命中率严重下降、内存命中率严重下降
    + 网络失败率上升、丢包率上升
        + 网络缓冲区溢出，丢包、拥塞，都在收发数据、却无法收发数据
+ 系统稳定性，系统雪崩、过大的超时时间、不合理的服务间依赖（弱依赖却很长的超时、）
    + 进程崩溃，没有足够的内存、被OOM
    + OS崩溃，么有足够内存

所以，系统不能运行在一个过载的压力下，需要运行在一个安全的阈值下。这就需要流量预估、限流、排队、资源配置管理、监控告警、网络攻击防范、系统漏洞安全升级等等。
+ 提前规划资源，流量预估
+ 系统架构优化，资源配置管理、自动扩展、负载均衡、高性能存储、异步队列
+ 实时监控和预警，实时监控、预警阈值、应急预案
+ 限流和排队机制，仿真压测、限流控制、队列盘对
+ 备份和恢复

# 分布式缓存的热迁移
为了：
+ 负载均衡，将过热的部分数据迁移到负载低的节点
+ 故障恢复，缓存完全不可用前，迁移到其他健康的节点，保障服务的连续性
+ 维护和升级，不停机维护

实现方式：
+ 共享存储，源和目标共享一个存储系统，迁移时只需更新节点的元数据和网络配置
    + 比如同一个数据库的不同表，同一个redis的不同的keys
+ 数据复制，源同步到目标，迁移时增量复制，待复制大部分数据，再切换时复制剩余的增量数据
+ 分布式存储系统，数据副本自动迁移，新增节点 =》 迁移数据 =》 剔除节点

关键技术
+ 数据一致性，迁移后的一致性校验 完整且准确
+ 低延迟、高吞吐，高速网络连接、高吞吐方案
+ 透明性，不影响用户和前端，中断无感

优化策略
+ 分批迁移，尽量快速
+ 提高应用程序的可靠性
+ 监控节点资源使用情况，避免过载

# 限流
为防止系统过载，控制请求的速率。

+ 固定窗口限流，将时间划分为固定大小的窗口，每个窗口内限制请求的数量
    + 确定窗口大小
    + 在每个窗口内记录请求的数量，当请求到达将请求计数加一
    + 如果请求计数超过预设阈值，则拒绝请求
    + 实现简单，但是会导致窗口边缘突发流量
+ 滑动窗口限流，通过滑动窗口的方式溢出过多的请求计数，从而更平滑地控制流量
    + 确定窗口大小和最大请求数
    + 记录窗口内的请求时间
    + 移除过期的请求
    + 检查当前窗口内的请求数是否超过阈值
    + 比前者更灵活，不会造成突发流量
+ 漏桶算法，通过一个固定容量的漏桶来控制请求的速率
    + 确定漏桶的容量和速率
    + 当请求到达时，将请求放入漏桶中
    + 漏桶以固定速率处理请求，以恒定的速率向下游请求
    + 如果漏桶已满，则丢弃或延迟处理新请求
    + 非常平滑突发流量，不能很好应对高峰
+ 令牌桶算法，通过一个固定容量的令牌桶来控制请求的速率
    + 初始化令牌桶，包括桶的容量和令牌生成速率。
    + 以固定速率向桶中添加令牌。
    + 当请求到达时，尝试从桶中获取一个令牌。
    + 如果获取成功，则请求通过；否则请求被限制。
    + 令牌桶算法的优点是可以允许突发流量（只要有桶中有令牌，数据包就可以向下游请求），同时限制平均速率，适合处理高并发场景。
+ 基于分布式协调服务的限流
使用分布式协调服务（如 ZooKeeper 或 etcd）实现限流。其基本方案如下：
初始化令牌桶，将令牌数量存储在分布式协调服务中。
请求到达时，向分布式协调服务申请令牌。
请求处理完毕后，释放令牌。
该方案可以实现精确的全局限流，但实现复杂，对分布式协调服务的性能要求较高。
+ 基于中心化的限流方案，用中心化组件（Redis）来控制所有服务器的请求
    + 定义限流规则，如每秒允许的最大请求数
    + 每个请求，向Redis请求令牌
    + 获取到令牌则处理请求，否则返回错误信息


漏桶算法，适用于需要严格控制请求速率的场景，如 API 网关限流。
令牌桶算法，适用于允许突发流量的场景，如秒杀场景。
滑动窗口限流算法，适用于需要平滑处理突发流量的场景。

## 漏桶算法 vs 令牌桶算法
+ 漏桶算法适用平滑处理、令牌桶适用一定的突发流量？
+ 前者简单易实现、资源消耗少，可能延迟较高、较多丢包
+ 后者复杂、资源消耗多，延迟抖动、负载抖动
+ 给核心流量配置少令牌校验，边缘流量配置多令牌校验？（错误说法，令牌桶不支持优先级）

如果非要说令牌桶有什么优点，我觉得对于高峰期的大量请求为轻请求、轻量级请求和关键重要请求又不能路由分开。

## 理想中的限流效果

+ 平滑处理流量（缓冲流量高峰、削去过载流量）
    + 每秒处理1k请求，缓冲了2k以上就意味着高峰延迟2s以上
    + 平滑的处理不是目的，目的是保护下游的服务。
    + 所以最好的限流能动态地根据实际负载限流，能感知到系统的饥饿和过载。
    + 分布式系统的负载上限取决于所有路径和节点的“最短板”。
    + 可能A类请求没有过载，但是B类请求过载了；也可能反过来。
+ 动态调整限流参数（可动态精细控制，可逐渐增加系统负载、结合系统监控指标，找出最佳参数）
+ 重要价值的流量优先处理，核心流量少限制，可服务降级流量给核心流量让路
+ 保障用户体验（服务不可用，服务延时过大）
+ 提供告警监控 和 预警阈值
+ 其他，可扩展

最终充分利用有限的资源，支撑最高的价值产出。


# 缓存机制

## 理想中的缓存
+ 高命中率、高吞吐量、低延迟
+ 高可用，冗余备份、故障转移、弹性伸缩（横向分区、水平扩展）
+ 一致性，强一致性、最终一致
+ 智能缓存，预热、淘汰策略
+ 低成本处理缓存穿透或缓存击穿
    + 获取到分布式锁，再次查看缓存命中，不命中才去更新
    + 
+ 其他，持久化、访问控制、低成本、监控告警