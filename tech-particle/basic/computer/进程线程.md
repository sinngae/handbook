# 进程线程专题
一个程序的执行？操作系统加载到内存，进程地址空间的代码区/数据区/堆/栈/系统保留区？

CPU的运行本质就是机器运行，就像齿轮传动一样。进程有时需要等待某事件，比如操作系统UI程序，一个机器一个进程独占的话，比较浪费，所以多进程模式，这样做更多事情。进程要做很多事，比如office，如果一直等待某事件，比较傻，而多进程又比较重量级，所以多线程，这样更灵活。

进程和线程是从CPU执行抽象出来的概念，与操作系统的PCB（进程控制块）和TCB（线程控制块）相对应。

进程是资源分配和调度的独立单位，线程是CPU调度的单位。
操作系统调度CPU时间片是分配给线程的，进程或线程申请资源都记录进程空间里。

进程有自己的进程地址空间；线程有独立的指令计数器、运行栈；
同一进程的多个线程共享进程的地址空间；不同进程之间共享数据，需要使用操作系统的共享内存。

同一程序的多个进程，一个进程死了，会向父进程发送信号。
同一进程的多个线程，一个线程退出程序或者被杀死，整个进程就退出了。如果线程本身退出，其父线程会收到信号，并做处理。

进程创建和销毁比较消耗资源（耗时，耗内存），线程更轻便。

操作系统不会把资源认为是某个线程独占的，却会认为是某个进程独占，当优先级更高的进程抢占时，也是从该进程抢占，判断死锁也是将该进程杀死。

进程和线程就像部门和成员一样，以部门为单位申请资源，操作系统以部门为单位管理资源。同部门的某些资源可以共用，不同部门的某些资源使用需要申请。当然公司没有CPU来执行某个成员，成员也不用被睡，哈哈。


## 进程

### 进程地址空间
![图1](process-addr.png)
![图2](process-userspace.png)
+ 1.进程使用虚拟内存中的地址，操作系统和硬件把它转成物理地址。 虚拟地址通过页表PageTable映射到物理内存
+ 2.内核空间在所有页表中拥有较高特权级别，因此用户态程序访问它将会导致一个页错误。
+ 3.内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。
+ 4.linux进程在虚拟内存中的标准内存段布局包括高地址的内核空间1GB与底地址用户空间3GB。用户空间地址有高到低包括命令行参数和环境变量、栈、堆、未初始化的数据、初始化的数据、正文。正文段，cpu指令部分，可共享的（内存中多个程序共享一个副本），只读的，写导致错误。初始化数据段，即数据段，包含程序中的全局变量。非初始化数据段，bss段，未初始化的全局变量和静态变量。栈，自动变量及函数调用信息。堆，动态存储分配。堆始于非初始化数据段顶和栈底之间，两者间隔很大。在编译时，函数地址及其他地址就已经确定了。readelf命令可以查看二进制文件中函数入口地址。
+ 5.32位windows，进程高位2G留给内核，低位2G留给用户，所以进程堆的大小小于2G，进程栈的大小默认是1M，vs的编译属性可以修改程序运行时进程的栈大小，一个线程栈的大小默认为1M，所以一个进程最多开2048个线程，实际最多大概2000个。
+ 6.linux下，进程高位1G留给内核，低位3G留给用户，所以进程堆的大小小于3G，进程栈的默认大小是10M，可以通过ulimit -s查看并修改默认栈大小。一个线程栈的大小默认为8M，所以最多380个左右线程。（ulimit -a查看linux的最大进程数大概7000多个。）
+ 7.线程共享的环境包括进程代码段、进程共有数据、进程打开的文件描述符、信号的处理器、进程的当前目录、进程用户ID与进程组ID。线程独立拥有自己的线程ID、寄存器组的指、线程函数栈区、错误返回码、线程信号屏蔽码、线程的优先级。window平台不同线程缺省使用同一个堆，所以用c的malloc分配内存的时候是使用了同步保护的。
+ 8.x86_64下，虚拟地址只用了48位，C程序里打印的地址只有12位16进制地址，48位对应了256TB的地址空间。64位地址前16位，4位16进制地址，全0是用户地址，全F是内核地址，这样分为两个128TB地址空间。内核空间有很多空洞hole，其中仅64TB才是直接映射物理内存的区域，PAGE——OFFSET为ffff8800 00000000
+ 9.pmap -x pid报告进程的内存映射关系
+ 10.malloc/free函数是通过brk，mmap，munmap等实现

## lib库的动态加载和静态加载机制
ELF，Executable and Linking Format，可执行链接格式。

ABI，Application Binary Interface，应用程序二进制接口。

目标文件有三种类型:
+ 可重定位文件(Relocatable File) .o  
包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据
+ 可执行文件(Executable File) .exe  
包含适合于执行的一个程序，此文件规定了exec() 如何创建一个程序的进程映像
+ 共享目标文件(Shared Object File) .so  
包含可在两种上下文中链接的代码和数据。
首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理， 生成另外一个目标文件。
其次动态链接器(Dynamic Linker)可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。
进程以共享读，可执行，不可写的方式读取.so文件。

**堆和栈的区别和适用场景**