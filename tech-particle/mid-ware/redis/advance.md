Advance
---

# 一亿个用户查两个人的共同好友

不差钱的情况下
首选Neo4j，也可以用MySQL 分库分表、Hbase+Hadoop离线计算。
Redis需要多大配置？
64GB Redis 可用空间 50GB，每个kv 1KB，则可以存5千万记录，此时单节点查询已经不足，需要水平扩展。

redis单节点理论上限 2^32 约43亿个key，这是哈希表的大小决定的。
实际值远低于这个，假设一组kv 100B，1GB内存大约可以存储 1千万。
多大的Val会影响页命中等，推荐单个kv 小于10KB（大Key可以拆成多个小key）。

通过合理优化，Redis可以轻松支持亿级数据。


# 一亿用户的实时积分排行榜
分成多个分数段，对应多个zset存储，超过则迁移。

# redis key过期了，为何（外部观察）内存没有释放

+ 严重时的影响
    + 内存压力过大
    + 性能下降
    + CPU负载增加
+ redis key的删除时机
    + 懒删除机制，key没有被访问会一直留在内存，只有访问时查看到已经过期 才会删除它
    + 定期删除机制，每隔一段周期，redis检查并删除过期的key（不一定是全部，平衡成本和性能；尤其是内存压力大的时候，优先保障服务可用）
    + 内存回收延迟，redis内存回收由后台线程执行
    + 内存碎片，大量key被删除，会导致内存碎片化，无法快速释放内存
    + 持久化策略，RDB或AOF可能是定时的、异步的持久化，所以不会立即删除生效
+ 怎么处理
    + （极端操作）手动触发内存回收，`memory purge`
        + CPU使用率瞬时上升
        + 读写响应延迟增加；主从同步延迟；持久化延迟；
        + 内存碎片仍然在，导致内存利用率较低
        + （redis内存占用接近系统的物理内存限制）触发Swap（内存、磁盘交换数据），性能显著降低
        + 极端情况OOM，redis内存不足导致被系统kill
    + 调整配置，增加定期删除频率，可能会增加CPU开销
        + 合理配置内存策略（淘汰策略、定期清理、过期时间）
        + 不在高负载情况下，手动触发内存操作
    + 优化key生命周期，打散在一段时间内，避免key同时过期
    + 内存监控告警，及时扩容升配、或 配置优化

# redis key没有设置过期时间，会被删除的情况
+ 删除命令执行 del key OR unlink key OR 脚本清理
+ 内存淘汰策略
    + 会过期的key，淘汰最近最少使用的key
    + 所有的key，淘汰最近最少使用的key
    + 会过期的key，随机删除
    + 所有的key，随机删除
    + 最接近过期时间的key，先删除
    + 默认，不删除key，内存不足时返回错误
+ 主从复制，主删了？；
+ 从异常中用持久化文件恢复，丢失了key


# redis集群模式用什么保证一致性
+ 主从复制
    + 全量同步，从节点长时间断联、丢失恢复，rdb文件
    + 增量同步，从节点同步延迟、短暂掉线
+ Gossip协议
    + 超过半数以上节点判定某节点不可达，则触发故障转移
    + 定期交换心跳信息
+ 故障转移
+ 持久化机制