Redis Cache
---
redis 不支持事务、不支持ACID，但是Redis支持原子操作（每个命令都可以看作是原子的，每个lua脚本的执行也可以看作原子的）。
简单的上锁也保证不了 redis操作+DB操作的原子性，因为redis没有隔离机制，没法try-confirm-rollback。

# 算法
数据加载到redis、带有过期时间（防止内存占用太多）

## 查询Cache miss处理
缓存击穿，（本来有，突然被删掉了）缓存过期了 Cache miss，大量查询请求直接请求到MySQL。
缓存穿透，（恶意攻击、无效key，如id=-1）缓存不存在，大量查询请求直接请求MySQL。

解决这俩问题，俩思路
+ 永不过期
+ 加锁排队

+ 请求Redis获取数据，取到则返回；
+ 没有，则加锁
    + 没锁成功，则等待一段时间
        + 再次到Redis中获取数据，没有则加锁
    + 可以用分布式锁，如果需要更高性能且易维护 也可以牺牲一点DB负载，使用单机OS互斥锁、每个实例允许一个穿透到DB
+ 加锁后，再次查看数据是否存在，存在则返回；
+ 不存在，则访问MySQL读取数据
    + 失败，则失败
    + 成功，则写入Redis
+ 返回数据


## 更新
如果 
先删除redcache，再修改数据库（不可行）。
+ 如果 另一个进程并发处理cache miss，就可能最终（有效时间内）redis中存的旧数据。需要再删一次，第一次删除没有意义了。


1. 先更新DB，再删缓存
+ 更新MySQL
+ 删除缓存
    + 如果cache miss并发处理，可能
    + 如果失败，如果
        + 重试（间隔较短时间，避免缓存中的数据过时太久，默认100ms；可以默认重试3次，看当前业务的容忍性、查询缓存业务的重要程度；可能引入问题，当前业务耗时增加）
            + 进程内重试皆失败，告警
            + 如果是很长时间的缓存，可以发到RocketMQ作异步重试
            + Cannel 读取MySQL binlog日志，做成事件触发来更新redis

2. 先更新DB，再更新缓存
逻辑不能和 查询cachemiss处理中的更新一样

+ 直接更新
+ 如果更新失败，则是否重试？不建议重试

### 删除会有什么问题
MySQL更新和Redis操作没法做到一个原子操作中，要么都成功、要么都失败

### 为什么不直接更新Redis

### 是否要 check 再更新



# 缓存雪崩
原因
+ 缓存同时刷新
+ Redis挂掉了，大量请求

处理：
+ 随机失效时间，key分布在同一刷新时间的范围内
+ redis扩容、分大区

## 主从切换导致的雪崩
并发量高的情况下
+ 主从延迟太大，导致切换过程中数据同步延迟
    + 主从切换中，从节点需要太长时间同步后才可提供服务
    + 主节点大量写，从节点无法和主节点完成同步
+ 主从切换过程中，客户端大量断开连接 进而大量重试
    + 大量的写比较容易崩
    + 大量的读，读性能下降
    + 严重时，触发超时重试（负载过高现象）
    + 全量同步？占满了网络IO？

+ 熔断限流
+ 资源预估提前配置
+ 合理设置客户端重试、主从同步配置
# 缓存穿透
+ 参数校验
+ 黑名单过滤器，可以应对一些重复的大量无效key
+ 前置布隆过滤器
+ 所有数据都缓存到Redis，没有查到则返回错误
