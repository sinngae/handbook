<mxfile host="65bd71144e">
    <diagram id="Esaw2zZWzbC2bJv0hkrR" name="Page-1">
        <mxGraphModel dx="832" dy="593" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
            <root>
                <mxCell id="0"/>
                <mxCell id="1" parent="0"/>
                <UserObject label="Kafka知识地图&#xa;    Broker&#xa;        配置项&#xa;            磁盘日志相关&#xa;                log.dirs&#xa;                    Broker需要使用的若干个文件目录路径，逗号间隔（必须配置）&#xa;                    最好配置到不同的物理磁盘上&#xa;                        提升读写性能&#xa;                        故障转移Failover&#xa;                        不用RAID&#xa;                log.dir&#xa;                    较早版本引入，不需要配置&#xa;            ZK相关&#xa;                zookeeper.connect&#xa;                    ZK配置，逗号间隔&#xa;            Broker-Client连接相关&#xa;                listeners&#xa;                    监听器，broker之间、client连接broker的协议&#xa;                advertised.listeners&#xa;                    broker对外发布的监听器，用于外网访问&#xa;                    技巧：Kafka Broker机器上配置了双网卡，一块网卡用于内网访问（即我们常说的内网IP）；&#xa;另一个块用于外网访问。那么你可以配置listeners为内网IP，advertised.listeners为外网IP&#xa;                host.name / host.port&#xa;                    不再使用&#xa;                listener.security.protocol.map&#xa;                    监听器协议底层使用了哪种安全协议&#xa;                    如CONTROLLER:PLAINTEXT表示CONTROLLER自定义协议底层使用明文不加密传输数据&#xa;            topic管理&#xa;                auto.create.topics.enable&#xa;                    是否允许自动创建topic&#xa;                    推荐false，避免误拼写引起的多于topic&#xa;                unclean.leader.election.enable&#xa;                    是否允许Unclean Leader选举&#xa;                    只有保存数据多的副本才能参与partion leader选举&#xa;如果仅有落后太多的副本，进行的选举即unclean选举&#xa;如果允许unclean选举，则数据有可能丢失&#xa;如果不允许unclean选举，则仅有落后太多的副本则该partition不可用&#xa;                    落后数量取决于replica.lag.time.max.ms&#xa;                    默认false，推荐显式设置为false&#xa;                auto.leader.rebalance.enable&#xa;                    是否允许Leader自动负载均衡选举，即定期换leader，使leader在broker均匀分布&#xa;                    如果分布不均超过leader.imbalance.per.broker.percentage，则触发选举&#xa;默认10%&#xa;                    换leader代价太高，client连接都要重新建立，推荐false&#xa;                    如果一个broker重启，没有分区leader；&#xa;true时，会做leader均衡；&#xa;false时，就永远不会做leader均衡；&#xa;                auto.offset.reset&#xa;                    consumer获取不到上次的offset，或读取到offset不可用时，采取的策略，如earliest / latest&#xa;            数据留存&#xa;                log.retention.{hours|minutes|ms}&#xa;                    消息数据保存的时间&#xa;                    优先级：ms&gt;min&gt;hour&#xa;                log.retention.bytes&#xa;                    broker保存消息的磁盘容量大小&#xa;                    -1标示不限制&#xa;                message.max.bytes&#xa;                    broker能够接收的最大消息大小&#xa;                    该设置不会预占用空间&#xa;                    需要broker/consumer/producer设置一致，或以最小的为准&#xa;replica.fetch.max.bytes&#xa;consumer fetch.message.max.bytes&#xa;            topic相关配置&#xa;                retention.ms&#xa;                    topic消息保存的时间&#xa;                retention.bytes&#xa;                    topic预留的磁盘空间，-1表示无限使用磁盘空间&#xa;                max.message.bytes&#xa;                    topic消息最大限制&#xa;            JVM参数&#xa;            操作系统参数&#xa;                文件描述符限制&#xa;                文件系统类型&#xa;                swap空间&#xa;                提交时间&#xa;                    flush落磁盘时间&#xa;        消息格式&#xa;            0.11.0之前，称作message set/message&#xa;0.11.0以后，称作record batch/record&#xa;            kafka网络传输和文件读写是以批次batch为单位的&#xa;            8字节offset；4字节消息长度；&#xa;            4字节CRC；1字节版本号；1字节属性；8字节时间戳；&#xa;4字节key长度；key；4字节value长度；value；&#xa;                v1.x引入时间戳，4字节producer/create_time；4字节broker/log_append_time&#xa;        topic&#xa;        partition&#xa;            leader/follower选举机制&#xa;            分区分配策略&#xa;                同一分区的不同副本均衡分布&#xa;                同一主题的不同分区leader均衡分布&#xa;            日志同步机制&#xa;            添加分区，不会有消息迁移&#xa;            删除分区，需要借助工具，人工迁移消息&#xa;        replica副本机制&#xa;            提供备份机制、分布式伸缩性、CDN效果？&#xa;            一个追加写消息的日志提交机制，不同topic的副本分散保存在不同的broker上&#xa;副本不用于读取&#xa;            leader选举&#xa;            In-Sync Replica （ISR）与leader保持同步的副本&#xa;                有时只有leader这一个副本&#xa;        磁盘文件&#xa;            日志文件索引&#xa;        时间轮&#xa;        与客户端通讯协议&#xa;        监听器&#xa;            若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;&#xa;协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；&#xa;也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092&#xa;        压缩算法&#xa;            节省带宽&#xa;        failover&#xa;            1.1之前，磁盘故障会引起broker宕机&#xa;1.1后，磁盘故障后broker做故障转移处理&#xa;    producer&#xa;        配置项&#xa;        生产均衡&#xa;            轮询策略&#xa;            随机策略&#xa;            按关键值策略，同一关键值有序&#xa;        压缩算法&#xa;            producer和broker使用相同的压缩算法，否则会重新压缩&#xa;            producer压缩、broker端保持、consumer端解压缩&#xa;            吞吐量：LZ4 &gt; Snappy &gt; zstd/gzip&#xa;            压缩比： zstd &gt; LZ4 &gt; gzip &gt; Snappy&#xa;            最好producerCPU资源富余，可节省broker的空间时间&#xa;        拦截器&#xa;        幂等生产者&#xa;    consumer&#xa;        配置项&#xa;        consumer group&#xa;            消费均衡 rebalance&#xa;        __consumer_offsets&#xa;        位移消费&#xa;        事务&#xa;        长轮询&#xa;        high level api&#xa;    特点&#xa;        高可用&#xa;            冗余&#xa;                多磁盘&#xa;                免RAID&#xa;                多partition，副本间复制&#xa;            producer均衡？&#xa;            consumer均衡&#xa;        高吞吐&#xa;            磁盘顺序读取，多磁盘，多分区读取&#xa;            批量消费&#xa;    golang客户端：sarama/sarama cluster&#xa;    最佳实践&#xa;        分区数量配置多少合适？&#xa;        无消息丢失配置&#xa;        子主题 3&#xa;    Kafka 监控&#xa;    Kafka Spark&#xa;    Kafka Streams&#xa;    Kafka Connect&#xa;Broker&#xa;    配置项&#xa;        磁盘日志相关&#xa;            log.dirs&#xa;                Broker需要使用的若干个文件目录路径，逗号间隔（必须配置）&#xa;                最好配置到不同的物理磁盘上&#xa;                    提升读写性能&#xa;                    故障转移Failover&#xa;                    不用RAID&#xa;            log.dir&#xa;                较早版本引入，不需要配置&#xa;        ZK相关&#xa;            zookeeper.connect&#xa;                ZK配置，逗号间隔&#xa;        Broker-Client连接相关&#xa;            listeners&#xa;                监听器，broker之间、client连接broker的协议&#xa;            advertised.listeners&#xa;                broker对外发布的监听器，用于外网访问&#xa;                技巧：Kafka Broker机器上配置了双网卡，一块网卡用于内网访问（即我们常说的内网IP）；&#xa;另一个块用于外网访问。那么你可以配置listeners为内网IP，advertised.listeners为外网IP&#xa;            host.name / host.port&#xa;                不再使用&#xa;            listener.security.protocol.map&#xa;                监听器协议底层使用了哪种安全协议&#xa;                如CONTROLLER:PLAINTEXT表示CONTROLLER自定义协议底层使用明文不加密传输数据&#xa;        topic管理&#xa;            auto.create.topics.enable&#xa;                是否允许自动创建topic&#xa;                推荐false，避免误拼写引起的多于topic&#xa;            unclean.leader.election.enable&#xa;                是否允许Unclean Leader选举&#xa;                只有保存数据多的副本才能参与partion leader选举&#xa;如果仅有落后太多的副本，进行的选举即unclean选举&#xa;如果允许unclean选举，则数据有可能丢失&#xa;如果不允许unclean选举，则仅有落后太多的副本则该partition不可用&#xa;                落后数量取决于replica.lag.time.max.ms&#xa;                默认false，推荐显式设置为false&#xa;            auto.leader.rebalance.enable&#xa;                是否允许Leader自动负载均衡选举，即定期换leader，使leader在broker均匀分布&#xa;                如果分布不均超过leader.imbalance.per.broker.percentage，则触发选举&#xa;默认10%&#xa;                换leader代价太高，client连接都要重新建立，推荐false&#xa;                如果一个broker重启，没有分区leader；&#xa;true时，会做leader均衡；&#xa;false时，就永远不会做leader均衡；&#xa;            auto.offset.reset&#xa;                consumer获取不到上次的offset，或读取到offset不可用时，采取的策略，如earliest / latest&#xa;        数据留存&#xa;            log.retention.{hours|minutes|ms}&#xa;                消息数据保存的时间&#xa;                优先级：ms&gt;min&gt;hour&#xa;            log.retention.bytes&#xa;                broker保存消息的磁盘容量大小&#xa;                -1标示不限制&#xa;            message.max.bytes&#xa;                broker能够接收的最大消息大小&#xa;                该设置不会预占用空间&#xa;                需要broker/consumer/producer设置一致，或以最小的为准&#xa;replica.fetch.max.bytes&#xa;consumer fetch.message.max.bytes&#xa;        topic相关配置&#xa;            retention.ms&#xa;                topic消息保存的时间&#xa;            retention.bytes&#xa;                topic预留的磁盘空间，-1表示无限使用磁盘空间&#xa;            max.message.bytes&#xa;                topic消息最大限制&#xa;        JVM参数&#xa;        操作系统参数&#xa;            文件描述符限制&#xa;            文件系统类型&#xa;            swap空间&#xa;            提交时间&#xa;                flush落磁盘时间&#xa;    消息格式&#xa;        0.11.0之前，称作message set/message&#xa;0.11.0以后，称作record batch/record&#xa;        kafka网络传输和文件读写是以批次batch为单位的&#xa;        8字节offset；4字节消息长度；&#xa;        4字节CRC；1字节版本号；1字节属性；8字节时间戳；&#xa;4字节key长度；key；4字节value长度；value；&#xa;            v1.x引入时间戳，4字节producer/create_time；4字节broker/log_append_time&#xa;    topic&#xa;    partition&#xa;        leader/follower选举机制&#xa;        分区分配策略&#xa;            同一分区的不同副本均衡分布&#xa;            同一主题的不同分区leader均衡分布&#xa;        日志同步机制&#xa;        添加分区，不会有消息迁移&#xa;        删除分区，需要借助工具，人工迁移消息&#xa;    replica副本机制&#xa;        提供备份机制、分布式伸缩性、CDN效果？&#xa;        一个追加写消息的日志提交机制，不同topic的副本分散保存在不同的broker上&#xa;副本不用于读取&#xa;        leader选举&#xa;        In-Sync Replica （ISR）与leader保持同步的副本&#xa;            有时只有leader这一个副本&#xa;    磁盘文件&#xa;        日志文件索引&#xa;    时间轮&#xa;    与客户端通讯协议&#xa;    监听器&#xa;        若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;&#xa;协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；&#xa;也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092&#xa;    压缩算法&#xa;        节省带宽&#xa;    failover&#xa;        1.1之前，磁盘故障会引起broker宕机&#xa;1.1后，磁盘故障后broker做故障转移处理&#xa;producer&#xa;    配置项&#xa;    生产均衡&#xa;        轮询策略&#xa;        随机策略&#xa;        按关键值策略，同一关键值有序&#xa;    压缩算法&#xa;        producer和broker使用相同的压缩算法，否则会重新压缩&#xa;        producer压缩、broker端保持、consumer端解压缩&#xa;        吞吐量：LZ4 &gt; Snappy &gt; zstd/gzip&#xa;        压缩比： zstd &gt; LZ4 &gt; gzip &gt; Snappy&#xa;        最好producerCPU资源富余，可节省broker的空间时间&#xa;    拦截器&#xa;    幂等生产者&#xa;consumer&#xa;    配置项&#xa;    consumer group&#xa;        消费均衡 rebalance&#xa;    __consumer_offsets&#xa;    位移消费&#xa;    事务&#xa;    长轮询&#xa;    high level api&#xa;特点&#xa;    高可用&#xa;        冗余&#xa;            多磁盘&#xa;            免RAID&#xa;            多partition，副本间复制&#xa;        producer均衡？&#xa;        consumer均衡&#xa;    高吞吐&#xa;        磁盘顺序读取，多磁盘，多分区读取&#xa;        批量消费&#xa;golang客户端：sarama/sarama cluster&#xa;最佳实践&#xa;    分区数量配置多少合适？&#xa;    无消息丢失配置&#xa;    子主题 3&#xa;Kafka 监控&#xa;Kafka Spark&#xa;Kafka Streams&#xa;Kafka Connect" link="Kafka知识地图&#xa;    Broker&#xa;        配置项&#xa;            磁盘日志相关&#xa;                log.dirs&#xa;                    Broker需要使用的若干个文件目录路径，逗号间隔（必须配置）&#xa;                    最好配置到不同的物理磁盘上&#xa;                        提升读写性能&#xa;                        故障转移Failover&#xa;                        不用RAID&#xa;                log.dir&#xa;                    较早版本引入，不需要配置&#xa;            ZK相关&#xa;                zookeeper.connect&#xa;                    ZK配置，逗号间隔&#xa;            Broker-Client连接相关&#xa;                listeners&#xa;                    监听器，broker之间、client连接broker的协议&#xa;                advertised.listeners&#xa;                    broker对外发布的监听器，用于外网访问&#xa;                    技巧：Kafka Broker机器上配置了双网卡，一块网卡用于内网访问（即我们常说的内网IP）；&#xa;另一个块用于外网访问。那么你可以配置listeners为内网IP，advertised.listeners为外网IP&#xa;                host.name / host.port&#xa;                    不再使用&#xa;                listener.security.protocol.map&#xa;                    监听器协议底层使用了哪种安全协议&#xa;                    如CONTROLLER:PLAINTEXT表示CONTROLLER自定义协议底层使用明文不加密传输数据&#xa;            topic管理&#xa;                auto.create.topics.enable&#xa;                    是否允许自动创建topic&#xa;                    推荐false，避免误拼写引起的多于topic&#xa;                unclean.leader.election.enable&#xa;                    是否允许Unclean Leader选举&#xa;                    只有保存数据多的副本才能参与partion leader选举&#xa;如果仅有落后太多的副本，进行的选举即unclean选举&#xa;如果允许unclean选举，则数据有可能丢失&#xa;如果不允许unclean选举，则仅有落后太多的副本则该partition不可用&#xa;                    落后数量取决于replica.lag.time.max.ms&#xa;                    默认false，推荐显式设置为false&#xa;                auto.leader.rebalance.enable&#xa;                    是否允许Leader自动负载均衡选举，即定期换leader，使leader在broker均匀分布&#xa;                    如果分布不均超过leader.imbalance.per.broker.percentage，则触发选举&#xa;默认10%&#xa;                    换leader代价太高，client连接都要重新建立，推荐false&#xa;                    如果一个broker重启，没有分区leader；&#xa;true时，会做leader均衡；&#xa;false时，就永远不会做leader均衡；&#xa;                auto.offset.reset&#xa;                    consumer获取不到上次的offset，或读取到offset不可用时，采取的策略，如earliest / latest&#xa;            数据留存&#xa;                log.retention.{hours|minutes|ms}&#xa;                    消息数据保存的时间&#xa;                    优先级：ms&gt;min&gt;hour&#xa;                log.retention.bytes&#xa;                    broker保存消息的磁盘容量大小&#xa;                    -1标示不限制&#xa;                message.max.bytes&#xa;                    broker能够接收的最大消息大小&#xa;                    该设置不会预占用空间&#xa;                    需要broker/consumer/producer设置一致，或以最小的为准&#xa;replica.fetch.max.bytes&#xa;consumer fetch.message.max.bytes&#xa;            topic相关配置&#xa;                retention.ms&#xa;                    topic消息保存的时间&#xa;                retention.bytes&#xa;                    topic预留的磁盘空间，-1表示无限使用磁盘空间&#xa;                max.message.bytes&#xa;                    topic消息最大限制&#xa;            JVM参数&#xa;            操作系统参数&#xa;                文件描述符限制&#xa;                文件系统类型&#xa;                swap空间&#xa;                提交时间&#xa;                    flush落磁盘时间&#xa;        消息格式&#xa;            0.11.0之前，称作message set/message&#xa;0.11.0以后，称作record batch/record&#xa;            kafka网络传输和文件读写是以批次batch为单位的&#xa;            8字节offset；4字节消息长度；&#xa;            4字节CRC；1字节版本号；1字节属性；8字节时间戳；&#xa;4字节key长度；key；4字节value长度；value；&#xa;                v1.x引入时间戳，4字节producer/create_time；4字节broker/log_append_time&#xa;        topic&#xa;        partition&#xa;            leader/follower选举机制&#xa;            分区分配策略&#xa;                同一分区的不同副本均衡分布&#xa;                同一主题的不同分区leader均衡分布&#xa;            日志同步机制&#xa;            添加分区，不会有消息迁移&#xa;            删除分区，需要借助工具，人工迁移消息&#xa;        replica副本机制&#xa;            提供备份机制、分布式伸缩性、CDN效果？&#xa;            一个追加写消息的日志提交机制，不同topic的副本分散保存在不同的broker上&#xa;副本不用于读取&#xa;            leader选举&#xa;            In-Sync Replica （ISR）与leader保持同步的副本&#xa;                有时只有leader这一个副本&#xa;        磁盘文件&#xa;            日志文件索引&#xa;        时间轮&#xa;        与客户端通讯协议&#xa;        监听器&#xa;            若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;&#xa;协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；&#xa;也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092&#xa;        压缩算法&#xa;            节省带宽&#xa;        failover&#xa;            1.1之前，磁盘故障会引起broker宕机&#xa;1.1后，磁盘故障后broker做故障转移处理&#xa;    producer&#xa;        配置项&#xa;        生产均衡&#xa;            轮询策略&#xa;            随机策略&#xa;            按关键值策略，同一关键值有序&#xa;        压缩算法&#xa;            producer和broker使用相同的压缩算法，否则会重新压缩&#xa;            producer压缩、broker端保持、consumer端解压缩&#xa;            吞吐量：LZ4 &gt; Snappy &gt; zstd/gzip&#xa;            压缩比： zstd &gt; LZ4 &gt; gzip &gt; Snappy&#xa;            最好producerCPU资源富余，可节省broker的空间时间&#xa;        拦截器&#xa;        幂等生产者&#xa;    consumer&#xa;        配置项&#xa;        consumer group&#xa;            消费均衡 rebalance&#xa;        __consumer_offsets&#xa;        位移消费&#xa;        事务&#xa;        长轮询&#xa;        high level api&#xa;    特点&#xa;        高可用&#xa;            冗余&#xa;                多磁盘&#xa;                免RAID&#xa;                多partition，副本间复制&#xa;            producer均衡？&#xa;            consumer均衡&#xa;        高吞吐&#xa;            磁盘顺序读取，多磁盘，多分区读取&#xa;            批量消费&#xa;    golang客户端：sarama/sarama cluster&#xa;    最佳实践&#xa;        分区数量配置多少合适？&#xa;        无消息丢失配置&#xa;        子主题 3&#xa;    Kafka 监控&#xa;    Kafka Spark&#xa;    Kafka Streams&#xa;    Kafka Connect&#xa;Broker&#xa;    配置项&#xa;        磁盘日志相关&#xa;            log.dirs&#xa;                Broker需要使用的若干个文件目录路径，逗号间隔（必须配置）&#xa;                最好配置到不同的物理磁盘上&#xa;                    提升读写性能&#xa;                    故障转移Failover&#xa;                    不用RAID&#xa;            log.dir&#xa;                较早版本引入，不需要配置&#xa;        ZK相关&#xa;            zookeeper.connect&#xa;                ZK配置，逗号间隔&#xa;        Broker-Client连接相关&#xa;            listeners&#xa;                监听器，broker之间、client连接broker的协议&#xa;            advertised.listeners&#xa;                broker对外发布的监听器，用于外网访问&#xa;                技巧：Kafka Broker机器上配置了双网卡，一块网卡用于内网访问（即我们常说的内网IP）；&#xa;另一个块用于外网访问。那么你可以配置listeners为内网IP，advertised.listeners为外网IP&#xa;            host.name / host.port&#xa;                不再使用&#xa;            listener.security.protocol.map&#xa;                监听器协议底层使用了哪种安全协议&#xa;                如CONTROLLER:PLAINTEXT表示CONTROLLER自定义协议底层使用明文不加密传输数据&#xa;        topic管理&#xa;            auto.create.topics.enable&#xa;                是否允许自动创建topic&#xa;                推荐false，避免误拼写引起的多于topic&#xa;            unclean.leader.election.enable&#xa;                是否允许Unclean Leader选举&#xa;                只有保存数据多的副本才能参与partion leader选举&#xa;如果仅有落后太多的副本，进行的选举即unclean选举&#xa;如果允许unclean选举，则数据有可能丢失&#xa;如果不允许unclean选举，则仅有落后太多的副本则该partition不可用&#xa;                落后数量取决于replica.lag.time.max.ms&#xa;                默认false，推荐显式设置为false&#xa;            auto.leader.rebalance.enable&#xa;                是否允许Leader自动负载均衡选举，即定期换leader，使leader在broker均匀分布&#xa;                如果分布不均超过leader.imbalance.per.broker.percentage，则触发选举&#xa;默认10%&#xa;                换leader代价太高，client连接都要重新建立，推荐false&#xa;                如果一个broker重启，没有分区leader；&#xa;true时，会做leader均衡；&#xa;false时，就永远不会做leader均衡；&#xa;            auto.offset.reset&#xa;                consumer获取不到上次的offset，或读取到offset不可用时，采取的策略，如earliest / latest&#xa;        数据留存&#xa;            log.retention.{hours|minutes|ms}&#xa;                消息数据保存的时间&#xa;                优先级：ms&gt;min&gt;hour&#xa;            log.retention.bytes&#xa;                broker保存消息的磁盘容量大小&#xa;                -1标示不限制&#xa;            message.max.bytes&#xa;                broker能够接收的最大消息大小&#xa;                该设置不会预占用空间&#xa;                需要broker/consumer/producer设置一致，或以最小的为准&#xa;replica.fetch.max.bytes&#xa;consumer fetch.message.max.bytes&#xa;        topic相关配置&#xa;            retention.ms&#xa;                topic消息保存的时间&#xa;            retention.bytes&#xa;                topic预留的磁盘空间，-1表示无限使用磁盘空间&#xa;            max.message.bytes&#xa;                topic消息最大限制&#xa;        JVM参数&#xa;        操作系统参数&#xa;            文件描述符限制&#xa;            文件系统类型&#xa;            swap空间&#xa;            提交时间&#xa;                flush落磁盘时间&#xa;    消息格式&#xa;        0.11.0之前，称作message set/message&#xa;0.11.0以后，称作record batch/record&#xa;        kafka网络传输和文件读写是以批次batch为单位的&#xa;        8字节offset；4字节消息长度；&#xa;        4字节CRC；1字节版本号；1字节属性；8字节时间戳；&#xa;4字节key长度；key；4字节value长度；value；&#xa;            v1.x引入时间戳，4字节producer/create_time；4字节broker/log_append_time&#xa;    topic&#xa;    partition&#xa;        leader/follower选举机制&#xa;        分区分配策略&#xa;            同一分区的不同副本均衡分布&#xa;            同一主题的不同分区leader均衡分布&#xa;        日志同步机制&#xa;        添加分区，不会有消息迁移&#xa;        删除分区，需要借助工具，人工迁移消息&#xa;    replica副本机制&#xa;        提供备份机制、分布式伸缩性、CDN效果？&#xa;        一个追加写消息的日志提交机制，不同topic的副本分散保存在不同的broker上&#xa;副本不用于读取&#xa;        leader选举&#xa;        In-Sync Replica （ISR）与leader保持同步的副本&#xa;            有时只有leader这一个副本&#xa;    磁盘文件&#xa;        日志文件索引&#xa;    时间轮&#xa;    与客户端通讯协议&#xa;    监听器&#xa;        若干个逗号分隔的三元组，每个三元组的格式为&lt;协议名称，主机名，端口号&gt;&#xa;协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等；&#xa;也可能是你自己定义的协议名字，比如CONTROLLER: //localhost:9092&#xa;    压缩算法&#xa;        节省带宽&#xa;    failover&#xa;        1.1之前，磁盘故障会引起broker宕机&#xa;1.1后，磁盘故障后broker做故障转移处理&#xa;producer&#xa;    配置项&#xa;    生产均衡&#xa;        轮询策略&#xa;        随机策略&#xa;        按关键值策略，同一关键值有序&#xa;    压缩算法&#xa;        producer和broker使用相同的压缩算法，否则会重新压缩&#xa;        producer压缩、broker端保持、consumer端解压缩&#xa;        吞吐量：LZ4 &gt; Snappy &gt; zstd/gzip&#xa;        压缩比： zstd &gt; LZ4 &gt; gzip &gt; Snappy&#xa;        最好producerCPU资源富余，可节省broker的空间时间&#xa;    拦截器&#xa;    幂等生产者&#xa;consumer&#xa;    配置项&#xa;    consumer group&#xa;        消费均衡 rebalance&#xa;    __consumer_offsets&#xa;    位移消费&#xa;    事务&#xa;    长轮询&#xa;    high level api&#xa;特点&#xa;    高可用&#xa;        冗余&#xa;            多磁盘&#xa;            免RAID&#xa;            多partition，副本间复制&#xa;        producer均衡？&#xa;        consumer均衡&#xa;    高吞吐&#xa;        磁盘顺序读取，多磁盘，多分区读取&#xa;        批量消费&#xa;golang客户端：sarama/sarama cluster&#xa;最佳实践&#xa;    分区数量配置多少合适？&#xa;    无消息丢失配置&#xa;    子主题 3&#xa;Kafka 监控&#xa;Kafka Spark&#xa;Kafka Streams&#xa;Kafka Connect" id="2">
                    <mxCell style="text;whiteSpace=wrap;" vertex="1" parent="1">
                        <mxGeometry x="360" y="320" width="560" height="4620" as="geometry"/>
                    </mxCell>
                </UserObject>
            </root>
        </mxGraphModel>
    </diagram>
</mxfile>