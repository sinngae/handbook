ID生成器
----

阿里单量最高峰值 2020年58.3w/s。
微信的消息数量峰值？
证券市场的交易峰值？

如何保障每个请求都能被唯一识别，进而跟踪处理？

# 前提

ID生成器 Demo版本：
i++需要0.5ns；互斥锁加锁解锁各需100ns。
估算每秒可以生成大约500万个ID。

ID 生成器 Alpha版本：
考虑ID生成器全局一致、持久化，且被多个服务请求。
假设在同一个局域网一份数据往返需要0.5ms。
MySQL、Redis等其他中间件的自增操作等远小于0.5ms。
则每秒可以生成大约2000个ID。

ID 生成器 Beta版本：
考虑ID生成器分布式可用（CA），考虑ID全局递增。
UUID/雪花算法？

基于Redis 自增ID：
1. 每个服务各自使用channel缓存（比如100）
2. 消费者
    + 读取chan获取一个ID
    + 空则阻塞等待
2. 生产者
    + 每次请求ID自增100，放到缓存中
    + 每当缓存可写，则请求ID =》 每当缓存中数量低于阈值，则请求ID
    + 缓存为空，则立即请求一段ID自增
    + 缓存低于阈值，则立即请求一段ID自增，否则
    + 缓存高于阈值

假设：
1. 每个服务上的ID消费需求是均衡的
2. 每个请求打到多个服务端上的是均衡的

ID生成器 Gama版本

库存的量，channel 缓冲区的 len（底层会加锁，不可频繁调用）
生产的量、速度的度量，记录每次自增ID的数量和时间点，即可统计5s内生产的速度。
生产的耗时，最近10次每次生产的网络请求耗时，取平均数。
消费速度度量，5s里生产的数量 减去 库存的变化量、再除以5。

动态的应当生产请求的库存，2倍 生产平均耗时 乘以 消费速度，并设置最小请求量限制。
生产的请求量，10倍 生产平均耗时 乘以 消费速度 - 存量，并设置最小请求量限制。



# Beta版本的问题
+ 高峰时消费者饥饿，缓存调大到1000
    高峰时，提高缓存？（缓存本身可以很大，放进去的量限制在100）
+ 低谷时期，ID全局自增趋势不明显
    + 低谷时，应当减少
+ 是否应该使用独立的ID生成服务？
    + 增加了复杂度，而且也没有必要性


1. 生产速度要尽量和消费速度持平
2. 维持低库存，库存保持在一次生成时间里的消费量