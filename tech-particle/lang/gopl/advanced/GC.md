GC
---
专门标识和清理动态内存分配的系统
+ 栈分配 - 空间存储在goroutine栈中，Go语言编译器能够预先确定何时释放内存，并发出清理内存的机器指令。
+ 动态内存分配 - 堆分配，Go语言编译器无法确定它的生存期，那么这些值就被称为“逃逸到堆”。

垃圾回收可能指自动回收内存的众多实现方法，例如引用计数。在本文档的上下文中，垃圾回收指的是跟踪垃圾回收，其通过循着指针来标识正在使用的、所谓的活动对象。

对象和指向其他对象的指针一起形成对象图。为了识别活动内存，GC从程序的根开始遍历对象图，程序明确使用的对象的指针。根的两个例子是局部变量和全局变量。遍历对象图的过程被称为扫描。

一旦它们发现内存是活的，它们会做什么。Go语言的GC使用了标记（mark）—清除（sweep）技术，这意味着为了跟踪它的过程，GC也会将它遇到的值标记为活动的。跟踪完成后，GC将遍历堆中的所有内存，并使所有未标记的对象的内存设置为可用于分配的内存。此过程称为扫描（scanning）。

另一种技术是将对象实际移动到内存的新部分，并留下一个转发指针，以后将使用该指针更新应用程序的所有指针。我们称以这种方式移动对象的GC为移动GC；Go的GC不是这样子的，它是非移动GC。

由于Go GC是一个标记—清除GC，因此它大致分为两个阶段：标记阶段和清扫阶段。  
在跟踪完所有内存之前，不可能释放内存以供分配，因为可能仍有未扫描的指针使对象保持活动状态。因此，清扫动作必须与标记动作完全分开。此外，当没有与GC相关的工作要做时，GC也可能根本不活动。GC在离开（off）、标记和扫描这三种状态之间不断循环，这就是所谓的GC循环。
# GC的成本模型
基于四个简单公理的GC成本模型。
1. 在GC执行时，应用程序会暂停。
2. GC只涉及两种资源：CPU时间和物理内存。
3. GC的内存开销包括活动堆内存、标记阶段之前分配的新堆内存，以及元数据空间（即使与前两个的开销成比例，但相比之下元数据空间开销也很小）。

注意：活动堆内存是由上一个GC周期确定为活动的内存，而新堆内存是在当前周期中分配的任何内存，在结束时可能是活动的，也可能不是活动的。
4. GC的CPU成本被建模为每个周期的固定成本，以及与活动堆的大小成比例的边际成本（marginal cost）。

注意：从渐进的角度来说，清扫的伸缩性比标记和扫描要差，因为它必须执行与整个堆的大小成比例的工作，包括被确定为非活动（即“死”）的内存。然而，在当前的实现中，清扫操作比标记和扫描快得多，因此在本讨论中可以忽略其相关成本。

# GC 的触发时机？
初级必问，分为系统触发和主动触发。

1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。

2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。

3）gcTriggerCycle：如果没有开启 GC，则启动 GC。

4）手动触发的 runtime.GC 方法。

# 大对象小对象，为什么小对象多了会造成 gc 压力？
小于等于 32k 的对象就是小对象，其它都是大对象。
一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。
优化思路是，减少对象分配。使用对象池

小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。

大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。

# GC流程
细分常见的三个问题：1、GC机制随着golang版本变化如何变化的？2、三色标记法的流程？3、插入屏障、删除屏障，混合写屏障（具体的实现比较难描述，但你要知道屏障的作用：避免程序运行过程中，变量被误回收；减少STW的时间）4、虾皮还问了个开放性的题目：你觉得以后GC机制会怎么优化？

Go 的 GC 回收有三次演进过程  
Go V1.3 之前普通标记清除（mark and sweep）方法，整体过程需要启动 STW，效率极低。GoV1.5 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通。GoV1.8 三色标记法，混合写屏障机制：栈空间不启动（全部标记成黑色），堆空间启用写屏障，整个过程不要 STW，效率高。

Go1.3 之前的版本所谓标记清除是先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW。Go1.3 版本标记清除做了点优化，流程是：先启动 STW 暂停，然后执行标记，停止 STW，最后再执行数据回收。

Go1.5 三色标记  
主要是插入屏障和删除屏障，写入屏障的流程：程序开始，全部标记为白色，
1）所有的对象放到白色集合，
2）遍历一次根节点，得到灰色节点，
3）遍历灰色节点，将可达的对象，从白色标记灰色，遍历之后的灰色标记成黑色，
4）由于并发特性，此刻外界向在堆中的对象发生添加对象，以及在栈中的对象添加对象，在堆中的对象会触发插入屏障机制，栈中的对象不触发，
5）由于堆中对象插入屏障，则会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加的白色对象依然是白色，
6）循环第 5 步，直到没有灰色节点，
7）在准备回收白色前，重新遍历扫描一次栈空间，加上 STW 暂停保护栈，防止外界干扰（有新的白色会被添加成黑色）在 STW 中，将栈中的对象一次三色标记，直到没有灰色，
8）停止 STW，清除白色。

至于删除写屏障，则是遍历灰色节点的时候出现可达的节点被删除，这个时候触发删除写屏障，这个可达的被删除的节点也是灰色，等循环三色标记之后，直到没有灰色节点，然后清理白色，删除写屏障会造成一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。

GoV1.8 混合写屏障规则是：

1）GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需 STW)，
2）GC 期间，任何在栈上创建的新对象，均为黑色。
3）被删除的对象标记为灰色。4）被添加的对象标记为灰色。

# GC 中 stw 时机，各个阶段是如何解决的？ （百度）

1）在开始新的一轮 GC 周期前，需要调用 gcWaitOnMark 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。

2）开始新的一轮 GC 周期，调用 gcStart 方法触发 GC 行为，开始扫描标记阶段。

3）需要调用 gcWaitOnMark 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。

4）需要调用 sweepone 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 Gosched 让出。

5）在本轮 GC 已经基本完成后，会调用 mProf_PostSweep 方法。以此记录最后一次标记终止时的堆配置文件快照。

6）结束，释放 M。



# 面对GC如何更好地编码使用内存
+ 限制G0routine数量，每个Goroutine都需要占用堆栈内存，
+ 字符串连接优化，避免使用加号运算符（导致频繁的内存分配和拷贝），建议使用strings.Builder 或 byte.Buffer。
+ 预先分配充足的内存，但不过度
+ 避免Map对象过大，过多的键值对 会导致map的扫描时间增加，只储存必要的键数据。
+ 使用sync.Pool 内存池复用内存
+ 增大GOGC的值，降低垃圾回收频率，效果有限 会导致更长的GC时间

# trouble shoot
如果Go程序频繁GC（正常为？），如何确定问题。

GOGC 为GC Percent参数，当程序堆内存使用超过上次GC完成时堆内存占用的 (100+n)%时，触发GC。一般默认为100（也即两倍，比如GC后为200MB，增长为400MB触发GC。如果第二次GC为250MB，下次则增长到500MB时触发GC）。

GO GC还有个触发的最大时间阈值，默认为 forcegcperiod 2min。动态调整，不能直接修改。
每次GC约0.1ms（理想情况下）。


1. `GODEBUG=gctrace=1 ./main` 可查看GC日志，关注用户代码运行时申请内存产生的垃圾。
2. `runtime/trace` 在代码上启动trace（），重点关注 GC事件的触发频率和持续事件，如果间隔几百毫秒，则说明过于频繁。如果堆内存呈现锯齿状变化，内存下降明显，关注下降比例是否很大。
3. go tool pprof，查看CPU消耗。关注runtime.gcDrainN等GC相关函数
4. 检查堆内存增长情况。关注一下下一次GC的预期内存大小是否过小。
5. 调整GOGC值。关注调大后，是否依然频繁GC 且 堆内存增长过大。
6. 关注CPU使用率，关注是否 使用率过高且频繁GC