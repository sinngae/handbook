goroutine
---
# 内存泄漏
go 中的内存泄漏一般都是 goroutine 泄漏，就是 goroutine 没有被正常退出，或者没有添加超时控制，让 goroutine 一直处于阻塞状态，不能被 GC。

+ 如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。
+ 互斥锁未释放或者造成死锁会造成内存泄漏
+ time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。
+ 字符串的截取引发临时性的内存泄漏
    + 如果被截取的字符串足够大，截取后使用的字符串截取足够小。在高并发场景中频繁使用，那么可想而知，会造成临时性内存泄漏，对性能产生极大影响
    + 解决方案是使用转成[]byte再转string，重新构建字符串
+ 切片截取引起子切片内存泄漏 （同上一个）
+ 函数巨大值拷贝，比如数组传参+高并发，函数参数来不及释放，就会占用大量内存

一般通过 pprof 是 Go 的性能分析工具

# 内存逃逸的情况如下：
1）方法内返回局部变量指针。

2）向 channel 发送指针数据。

3）在闭包中引用包外的值。

4）在 slice 或 map 中存储指针。

5）切片（扩容后）长度太大。

6）在 interface 类型上调用方法。
多态，方法的地址是运行时才确定的，只能放在堆上？代码块不都是在一个内存区域么？

