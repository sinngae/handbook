GMP
---
+ G - Goroutine Go代码中起的协程（？Go编译器定义的协程呢）
+ M - 内核线程，操作系统不会感知到G和P，只知道自己在执行一个线程。G和P都是Go程序用户态的实现。
+ P - 调度器 Processor，提供本地队列，管理一组协程

# 关键场景
设计思想：
+ 线程及其时间片复用 work stealing机制 和 hand off机制
+ 利用CPU多核
+ 抢占调度（解决公平性问题）

被调用的G
+ P的run next，下一个被调用的G
+ P的本地队列（G数组，长度256）
+ 全局G队列（链表，无限制）
+ 网络轮询器（network poller，存放网络IO阻塞的G）

P - 全局P队列（数组，GOMAXPROCS）

M线程
- 休眠线程队列（未绑定P？）
- 运行线程（绑定了P）
- 自旋线程（绑定P，指向M的G0）

- 普通M，用来与P绑定执行G中任务
- m0：Go程序是一个进程，进程都有一个主线程，m0就是Go程序的主线程，通过一个与其绑定的G0来执行runtime启动加载代码；一个Go程序只有一个m0
- 运行sysmon的M，主要用来运行sysmon协程。

运行线程+自旋线程 >= P数量；M数量 >= P数量

## 调度
生命周期
+ go func创建协程
+ 进入局部队列
    + 局部队列满，则进入全局队列
+ 获取G
    + P队列为空，则从全局队列获取
    + 全局队列没有，则从其他P“偷取”
+ 调度G
+ 执行G func
+ 系统调用或IO阻塞
    + 创建一个M或从休眠M队列获取一个
+ 销毁G，执行完毕

调度时机
+ 抢占式调用 - sysmon检测，如sleep 死循环等长时间占用的
+ 主动调度
    + 新增协程 或 协程执行结束
    + 主动调用 runtime.Gosched
    + 垃圾回收后
+ 被动调度
    + 系统调用阻塞，如文件IO阻塞（同步等待）
    + 网络IO调用阻塞（异步）
    + atomic/mutex/channel等阻塞（同步等待）

调度策略
+ 每执行61次调度循环，从全局队列获取G，若有则直接返回
+ 从P上的runnext看一下是否有G，若有则直接返回
+ 从P上的本地队列看一下是否有G，若有则直接返回
+ 上面都没查找到时，则去全局队列、网络轮询器查找或者从其他Р中窃取，一直阻塞直到获取到一个可用的G为止

sysmon协程  
sysmon协程也是runtime的一部分，sysmon协程直接运行在M不需要P，主要做一些检查工作如：检查死锁、检查计时器获取下一个要被触发的计时任务、检查是否有ready的网络调用以恢复用户G的工作、检查一个G是否运行时间太长进行抢占式调度。

work stealing机制  
窃取的实质就是随机遍历P队列所有p，查看其运行队列是否有goroutine，如果有，则取其一半到当前工作线程的运行队列

hand off机制  
也称为P分离机制，当本线程M因为G进行的系统调用阻塞时，线程释放绑定的P，把Р转移给其他空闲的M执行，也提高了线程利用率（避免站着茅坑不拉shi)。

抢占
+ 死for循环没法抢占
+ 编译器会在调用函数前插入runtime.morestack，让运行时有机会在这段代码中检查是否需要执行抢占调度。超过阀值则抢占

查看运行时调度信息：
有2种方式可以查看一个程序的调度GMP信息，分别是go tool trace和GODEBUG


P的状态  
+ 当程序刚开始运行进行初始化时，所有的P都处于_Pgcstop状态，随着的P的初始化（runtime.procresize），会被设置为_Pidle状态。
+ 当M需要运行时会调用runtime.acquirep来使P变为_Prunning状态，并通过runtime.releasep来释放，重新变为_Pidele。
+ 当G执行时需要进入系统调用，P会被设置为_Psyscall，如果这个时候被系统监控抢夺（runtime.retake），则P会被重新修改为_Pidle。
+ 如果在程序中发生GC，则P会被设置为_Pgcstop，并在runtime.startTheWorld时重新调整为_Prunning。

# 分析
## 协程的特点：栈大小 上下文切换
线程栈一般是2MB，而且运行时不能更改大小；
Go的协程栈只有2kb，而且可以动态扩容（64位机最大为1G）；

非g0的g为什么要在堆上分配空间？  
虽然堆不如栈快，但是goroutine是go模拟的线程，具有动态扩容和缩容的能力，而系统栈是线性空间，在系统栈上发生缩容和扩容会存在空间不足或者栈空间碎片等问题；所以go这里在堆上分配协程栈；因为是在堆空间也就意味着这部分空间也需要进行垃圾回收和释放；所以Go的GC是多线程并发标记时，内存屏障是对整个协程栈标记灰色，来让回收器进行扫描

上下文切换速度  
协程的切换速度远快于线程，不需要经过内核与用户态切换，同时需要保存的状态和寄存器非常少；线程切换速度为1-2微秒，协程切换速度为0.2微秒左右

## 为什么要有P
如果没有P =>  
G存放在一个全局协程队列中，存放的是就绪的协程（和其他未就绪的协程？）。多个M在调度G的时候如果想从这个全局队列获取G，就要通过全局的锁来（并发安全地）获取，这就造成了性能瓶颈。

增加了P，P提供了本地队列，供M获取G来运行。P队列为空时，则从全局队列中获取。
+ M访问其对应的P队列不用加锁。
+ P队列很少从全局队列中获取G。
+ 如果全局队列中没有，则从其他P队列中“偷取”，偷取的频率也不应该高

P队列的大小为256，（拍出来的数字，并没有什么道理）调整该值的方法是？

P可以理解成是基于M线程（可能是多个）虚拟出来的处理器，其上可以并发运行相当于多个进程的多个任务。

会不会在P上虚拟出来多个线程？目前看来没有必要。
进程这层对应的资源，如内存块、访问的文件、连接、端口，进程维度上独占资源；
线程这层对应的是CPU时间片，多个线程在CPU核上被调度；
协程这层对应的是用户的任务，每个协程就是一个独立运行的任务（Unix中成为作业）；

## 并发和并行的区别
+ 并发 - concurrent 逻辑上同时处理不同的任务
+ 并行 - parallel 物理上同时处理不同的任务

区别要看时间跨度，瞬时的并发和并行是一回事；在某一时间段里，并行处理的肯定并发，并发处理的不一定是并行的。

单个处理器的单个核上，通过时间片分配来串行执行任务（不考虑超线程、超流水技术）；多个核并发地处理多个任务。
Go协程可以充分利用多核，同一瞬时多个核上并发执行任务；某一时间段里，多个协程也可能都是并发执行。最大的并发执行数量就是核数。

## Go协程怎么就充分利用多核了？
协程执行到IO阻塞只需要调度到另一个协程，直到M线程的时间片用完。

多进程或多线程，如果IO阻塞，一般会放弃当前时间片，进入waiting状态。

多线程遇到IO阻塞，不能将当前流程挂起，去做别的任务么？当然可以，这不就是协程做的么？多线程实现起来会相当复杂。

** 所以协程本质上就是解决了n个线程m个任务（m >> n）的IO阻塞的开发复杂的问题。**

## 常见的goroutine操作函数
+ runtime.GOMAXPROCS(num int)可以设置线程数目。该值默认为CPU逻辑核数，如果设的太大，会引起频繁的线程切换，降低性能。
+ runtime.Gosched()，用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。
+ runtime.Goexit()，调用此函数会立即使当前的goroutine的运行终止（终止协程），而其它的goroutine并不会受此影响。runtime.Goexit在终止当前goroutine前会先执行此goroutine的还未执行的defer语句。 
  请注意千万别在主函数调用runtime.Goexit，因为会引发panic。
+ runtime.LockOSThread()，将此协程和M线程绑定，其他协程不会被调度，

