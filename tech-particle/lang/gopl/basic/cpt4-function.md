# 第四章 函数
函数机制用于程序分解为一个个单元。递归函数、匿名函数、错误处理等。

## 1. 函数声明
函数名、形式参数列表、返回值列表、函数体`·func name(param-list) (return-list) { body }`。
```go
func f(i, j int, s, t string) (z int) { z = i+j; return }
func f(i int, j int, s string, t string) int { return i+j } // 等价的声明
func f(i int, _ int) int { return i }
func f(int, int) int { return 0 }
```
上述四种声明的func的Printf参数%T都是`func(int, int) int`。

函数的类型被称为函数的标识符，如果两个函数形参列表和回值列表的边浪类型一一对应，则这两个函数称为有相同的类型和标识符。
Go语言函数没有默认参数值。
函数调用者不关系函数声明的形参名，仅需依序提供实参列表。
Go语言实参和形参是值拷贝传递，即使是指针等数据结构，不过指针提供一种间接访问。

没有函数体，仅声明了标识符的函数一般不是Go实现的。

## 2. 递归
大部分编程语言使用固定大小的函数调用栈，从64KB到2MB不等，限制了递归的深度，程序中需要避免栈溢出及安全性问题。
Go语言使用可变栈，栈的大小按需增加，使用递归时不必考虑溢出和安全问题。

## 3. 多返回值
可以将一个返回多参数的函数作为一个接受多参数函数的参数，很利于调试，但实际上很少这样做。?
Go语言惯例：函数的最后一个bool类型的返回值标识函数是否运行成功，error类型的返回值代表函数的错误信息，不必有命名。
bare return：一个函数所有的返回值都有显式变量名，则该函数的return语句可以省略操作数。
bare return可以减少代码重复，但可读性下降，不宜过度使用。

## 4. 错误
Go语言中，部分函数总能成功，部分函数输入满足条件也能成功，大部分函数不能确保成功。
Go语言的错误处理中，程序运行失败被认为是预期的结果之一。
惯例：一些函数的最后一个返回值通常用于传递错误信息，可以是个布尔值或error类型。
error类型是接口类型，可能是nil，表示函数运行成功；或non-nil，表示失败，此时其他返回值是未定义的，应当被忽略。
error的Error函数或输出函数可获得字符串类型的错误信息。
error错误与异常不同，异常是未预期的错误，而不是已经被避免的错误。

### 错误处理策略
1.传播错误。
2.重试失败的操作，限制间隔和次数。（偶然性的、不可预知的问题导致的？不可靠的网络。）
3.输出错误信息并退出。（只应在main中执行）
4.输出错误信息，继续。
5.直接忽略，处理。（某些系统自会处理的事情，或自恢复的）

惯例：错误信息以链式组合在一起，避免大写和换行符，便于grep处理。错误信息应该详尽且表达一致。

log.Fatalf()导致程序退出。
log包的SetPrefix和SetFlags函数。

Go语言推荐风格：失败的逻辑代码放在成功的前面，成功的代码直接放在函数体中。

### 文件结尾错误EOF
io包的任何由文件结束引起的读取失败都返回同一个错误io.EOF。
error错误可以==比较。

## 5. 函数值
Go语言中，函数被归于第一类值first-class values：拥有类型，可被赋值给变量，传递给函数，从函数返回。其调用与函数调用相同。
函数类型的零值是nil，对其调用引起panic错误，函数值可与nil比较，不可互相比较，不可做map的key。

## 6. 匿名函数
函数字面量，可在表达式中表示一个函数值。与函数声明类似，但没有函数名，称为匿名函数。
匿名函数可以访问其词法环境，即命名函数内嵌的匿名函数可以引用函数的变量。
Go语言函数值不仅是代码块，还记录了状态，匿名函数可以访问和更新其上层函数的局部变量，或者说匿名函数里保存有该局部变量的引用。
Go语言使用闭包技术实现函数值，函数值即闭包。
所以，变量的生命周期不由其作用域决定。

### 警告：捕获迭代变量
因为for的循环变量的作用域单独一层，循环体内是一层，内层的匿名函数访问了上层的循环变量，使该循环变量成为匿名函数的记录。所以多次匿名函数引用for的循环变量，可能导致匿名函数最终被调用时不符合预期，需要先保存在循环内部的变量中，再被匿名函数访问。
该问题同样存在于range循环、go语句、defer语句等。

## 7. 可变参数
函数的参数列表的最后一个参数的类型之前加上省略符号，表示该函数可接受多个该类型参数，该参数称为可变参数。
可变参数可以当作切片处理，但并不是切片。是一种隐式类型？
将切片传递给可变参数，需要在其后加上省略符号。
被interface{}修饰的参数表示接收任意类型。

## 8. Deferred 函数
defer修饰的语句会在其所在的函数执行完毕时（包括return、panic异常等）执行。
defer常用于处理成对的操作，打开关闭、连接断开、加锁释放等。
一个函数中多个defer语句的执行顺序与其声明顺序相反。

defer机制加上匿名函数用于记录何时进入和退出函数（defer修饰一个函数返回的匿名函数的执行语句，切记不能少了最后的函数调用运算符()。
defer机制加上匿名函数可以将函数体后部分的语句前置。

当defer用于for循环中释放资源，最好将for循环中的打开资源和释放资源封装到一个函数中。

defer延后执行的语句最好不要用于覆盖函数体中语句的执行的结果。

## 9. Panic异常
数组访问越界、空指针引用等，这类运行时panic异常，会中断运行，并立即执行goroutine中被延迟defer的函数，随后程序崩溃并输出日志信息。
panic日志信息包括panic value和函数调用的堆栈跟踪信息。
panic内置函数也会引发panic异常，接收任何类型参数。类似于Clang中的assert断言。
惯例：panic函数适用于某些理论上可能发生，实际不应该发生的逻辑路径上。
除非需要提供跟多的错误信息，否则不必使用panic函数。
panic一般用于程序内部逻辑不一致（不自洽），并引起程序崩溃的严重后果。
一般应该使用错误机制处理大部分的预料的错误，而不是panic。预料之外的错误应该使用panic函数？
Go语言倾向契约式编程，程序内部的调用者应该遵守被调用者的契约或预期，否则触发panic异常。
惯例：Go语言函数名的Must前缀标识该函数不接收不合法的输入。兼容了契约式编程和防御式编程。

panic函数加上defer机制可以完成优雅退出，defer语句在释放堆栈信息之前执行。

runtime.Stack函数获取堆栈信息。

## 10. Recover捕获异常
一般不该对panic异常做处理。
web服务器崩溃前应该把所有连接关闭，避免客户端一直等待；开发阶段中服务器端崩溃前把异常信息反馈给客户端，便于调试。
如果defer函数中调用了内置函数recover()，且其所在函数执行出了panic异常，recover使执行从panic中恢复，并返回panic value，最终发生panic异常的函数不再运行，但可正常返回。

把所有panic异常都恢复的做法会导致漏洞被忽略，并不可取，且不能包级变量是否与预期一致。
一个包里的逻辑不应该去恢复其他包引起的panic，也不应该恢复外部传入的函数参数的执行引发的panic（无法保证安全性）。

web服务的业务处理函数导致的panic时，会调用recover，输出堆栈信息，恢复执行，很便捷但也容易出问题。

惯例：recover时对panic value检查，如果是特殊类型，则作为error处理，并恢复执行，否则异常崩溃。

有些情况，无法恢复，如内存不足，Go程序必须终止运行。