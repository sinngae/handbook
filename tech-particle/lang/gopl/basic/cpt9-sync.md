sync
---

# Mutex 有几种模式？

1. 正常模式
+ 当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。
+ 新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。
+ 新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。

2. 如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。

3. 饥饿模式
+ 在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 

4. 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:
    + 此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；
    + 此 waiter 的等待时间小于 1 毫秒。

5. goroutine 的自旋占用资源如何解决  
自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。

自旋的条件如下：
+ 还没自旋超过 4 次,
+ 多核处理器，
+ GOMAXPROCS > 1，
+ P的本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

## 自旋的有益性
假设即使是协程上下文切换，耗费是100；而自旋的成本是前者的p%；
假设n次加锁中有x%的比例没有上下文切换，而是自旋后获得了锁，自旋成本是 `100 * p% * n`；而不自旋的模式下的成本是 `100 * n * x%`;
那么只要`p < x`，自旋就是有益的。实际p确实是小于x的。


