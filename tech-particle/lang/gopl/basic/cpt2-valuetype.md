# 第二章 基础数据类型
所有数据都是由比特组成，整数、浮点数、比特数组、内存地址等，复合在一起组成更丰富的类型，数据包、像素点、文档。
Go语言内置数据类型：基础类型（数字、字符串、布尔型）、复合类型（数组、结构体）、引用类型（指针、切片、字典、函数、通道）、接口类型。

## 1. 整型
int8/int16/int32/int64;
uint8/uint16/uint32/uint64;
机器字长int/uint，取决于编译器和硬件平台。
Unicode字符rune类型与int32类型等价，用于表示一个Unicode码点，可以互换使用。
byte等价于uint8，更强调是一个原始的数据。
无符号整数类型uintptr，没有具体的bit大小，但足以容纳指针，仅用于底层编程，特别是Go语言与C语言函数库或操作系统接口交互的地方。
int与int32不同，需要显式类型转换操作。
有符号整数是2的补码形式表示，最高bit位表示符号位，其值域从-2^(n-1)到2^(n-1)-1。无符号整数，无符号位，表示非负数，从0到2^n-1。
建议：使用小括号明确优先级，提高可读性。
取模运算符%仅用于整数，且结果的符号和被取模数一致。
Go语言同样也会因计算而溢出，需要被处理。
整数、浮点数、布尔型、字符串等是可比较的，可排序，存在类型不可排序。？取决于？
按位异或^。&^是?
左移运算用零填充右边空位，无符号数右移运算也是用0填充左边空位，有符号数的右移运算用符号位填充左边空位。
位移运算最好用于无符数处理。
Go语言数组长度函数len()返回的是有符号int，可以逆序循环（无符号数导致panic）。
Go语言表达非负数量倾向于用有符号整数类型，无符号数仅用在位运算、bit集合、分析二进制文件格式、哈希操作、加密操作等。
八进制格式书写的整数字面值以0开始，十六进制的以0x/0X开头。八进制常用于POSIX操作系统上文件访问权限标志，十六进制更强调数字值的bit位模式。
格式化输出%d/%o/%x，指代不同进制。
字符使用%c参数打印，%q参数打印带单引号的字符。

## 2. 浮点数
Go语言浮点数float32和float64，由IEEE754浮点数国际标准定义，被所有的CPU支持。
float32最大值math.MaxFloat32约3.4e38，最小值math.MinFloat32约1.4e-45；float64最大值math.MaxFloat64约1.8e308，最小值math.MinFloat64约4.9e-324。
通常应该优先使用float64，因为float32的累计计算误差很容易扩散。
%g参数采用更紧凑的表示形式打印；%e、%f参数更合适表格数据。
注意：浮点数的相等比较，不能直接比较。（两者之差小于一个阈值，即可认为两者相等）

## 3. 复数
Go语言提供复数类型complex64/complex128（对应float32/float64），内置函数complex()构建复数，内建的real和imag函数返回复数的实部和虚部。
Go语言源文件中实数面值后面跟着i，即构成复数虚部。

## 4. 布尔型
布尔值的短路行为：如果运算符左边的值已经可以判断整个布尔表达式的值，右边的值将不被求值。
&&比||优先级高。
布尔值不能隐式转换为数字值0或1可借if语句转换。

## 5. 字符串
一个字符串是一个字节序列，可以包含任意数据。
文本字符串通常解释为采用UTF-8编码的Unicode码点(rune)序列。
内置len函数返回字符串的字节数目，而不是rune字符数目。
索引操作str[idx]需要满足：`0<= idx < len(str)`，否则引起panic异常1。
子字符串操作str[i:j]生成一个新字符串，即原始str的第i字节开始到j字节（不包含j），j小于i导致panic异常，0和len(str)可省略。
字符串不可修改，对字符串内部数据的赋值操作是被禁止的，导致编译错误（不变性）。

### 字符串面值
字符串面值可以用双引号包含字节序列，需要使用大量转义。
Go语言总用UTF8编码，其文本字符串，也以UTF8编码处理，Unicode码点也可以写到字符串面值中。
通过十六进制或八进制转义在字符串面值包含任意的字节，十六进制\xhh(两个数字，如\xFF、\x05)，八进制\ooo(三个数字，如最大\377)。

原生的字符串面值形式 `cccc`，使用反引号代替双引号，没有转义操作，全部内容即字面意思，包含退格和换行，可跨越多行（无法书写的字符用八进制或十六进制转义或+"..."链接字符串常量）。
Go语言会删除原生字符串中的回车以保证所有平台上的值都是一样的。
原生字符串面值常用于编写正则表达式、HTML模版、JSON面值、命令行提示信息等需要扩展多行、很多反斜杠的地方。

### Unicode
ASCII使用7bit表示了128个字符（英文字母大小写、数字、各种标点符号、设置控制符）。
Unicode符号集，收集了世界上所有的符号系统，每个符号都分配一个唯一Unicode码，Go语言都有一个rune类型对应（rune英文意思是符文）。
Unicode第八版标准收集了12万字符，100多种语言。
Unicode通用int32表达，符文序列可以表示为一个int32序列（即UTF-32或USC-4），简单统一却浪费很多空间。

### UTF-8
UTF8将Unicode编码为变长字节的编码序列（Go语言之父也是Unicode之父之一）。
UTF8使用每个编码的第一个字节的高端bit表示共有多少字节。
UTF8中，ASCII部分字符仅使用1个字节，常用字符部分使用2或3个字节，首字节高端bit为0。
如果首字节高端bit是110，则共有2字节；如果是1110，则共有3字节；如果是11110，则共有4字节。
除首字节之外的字节，高端bit都以10开头。

变长字节编码，无法通过索引访问第n个字符。
但是编码紧凑，完全兼容ASCII编码，可以自动同步（向前回溯2个字节即可确定字符编码的开始字节位置）。
UTF8是个前缀编码，从左向右解码不会有任何歧义，也不需向前查看（GBK编码如果没有起点位置，会出现歧义）。
UTF8的每个编码的字节组是唯一的，不会互相影响。

UTF8编码顺序和Unicode码点顺序一致，可以直接排序UTF8编码序列，比较大小等。
UTF8编码中没有NUL(0)字节，可以兼容使用NUL做结尾的编程语言。

Go语言采用UTF8编码，提供了unicode/utf8包，用于rune字符序列的UTF8编解码功能。
Go语言支持Unicode码点转义字符，\uhhhh对应16bit的码点值，\Uhhhhhhhh对应32bit的码点值。
下面的字符串面值表示相同：
```go
"世界"
"\xe4\xb8\x96\xe7\x95\x8c"
"\u4e16\u754c"
"\U00004e16\U0000754c"
```

Go语言的range循环在处理字符串时，会隐式解码UTF8字符串。
如果遇到一个错误的UTF8编码字符，将生成一个特别的Unicode字符'\uFFFD'，印刷中是一个黑色六角或钻石形状，包含一个白色的问号。

UTF8字符串作为交换格式很方便，但程序内用rune序列处理更方便，rune序列的每个字符大小一致，支持数组索引且方便切割。
string转[]rune，将一个UTF8编码的字符串解码为Unicode字符序列；[]rune类型的Unicode字符slice或数组转string，则做UTF8编码。
整数转型为string的意思是，生成对应Unicode码点字符的UTF8字符串。

### 字符串和Byte切片
Go语言标准库涉及字符串处理常用四个包：bytes、strings、strconv、unicode。
strings提供字符串查询、替换、比较、截断、拆分、合并。
bytes提供strings类似功能，但针对[]byte类型。相比strings，bytes.Buffer的处理更高效。
strconv提供了布尔、整型、浮点、字符串、双引号转译的相互转换。
unicode提供了IsDigit、IsLetter、IsUpper、IsLower等功能，遵循Unicode标准，处理rune类型。

path和path/filepath包提供了关于文件路径名的一些函数操作（使用操作系统本身的路径规则）。


```go
s := "abc"
b := []byte(s)
s2 := string(b)
```
[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。
编译器做优化，以避免一些场景下分配和复制字符串数据，确保变量b被修改的情况下，原始的s字符串也不会改变。
string(b)操作则是构造了一个字符串拷贝，s2是只读的。

strings和bytes包有很多函数相似，区别是字符串类型参数被替换成了字节slice类型的参数。
bytes.Buffer类型用于字节slice缓存，可以当作I/O的输入和输出对象。

### 字符串和数字的转换

## 6. 常量
常量表达式在编译期间计算。每种常量的潜在类型都是基础类型（布尔、string或数字）。
函数len、cap、real、imag、complex和unsafe.Sizeof返回的都是常数。
%T打印类型信息。

批量声明的常量，第一个常量的右值表达式不可省略，后续省略右值表达式的常量使用前面常量的初始化表达式（没有太实用价值，但可以带来iota常量生成器语法，即Go语言枚举类型）。

### iota常量生成器
```go
type Weekday int

const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
```
iota常量生成器用于生成一组以相似规则初始化的常量，不用声明每行都初始化。
第一个被置为0，其他的逐行加一。
如果是`1 << iota`，则依次是连续的2的幂。
iota不能产生10的幂，因为Go语言没有幂运算符。

### 无类型常量
Go语言的很多常量没有明确的基础类型，编译器为他们提供比基础类型更高精度的算数运算（256bits?）。
有六种未明确的常量类型：无类型布尔型、无类型整数、无类型字符、无类型浮点数、无类型复数、无类型字符串。
无类型常量，提供更高的运算精度，远超任何Go语言的整数类型表达。
无类型浮点数常量，可以直接用于任何需要浮点数的地方（隐式转换），不需显式转换。
常量面值、字符串面值常量都是无类型的常量。
无类型常量类型转基本类型。
无类型常量转接口，以明确接口对应的动态类型。
%T打印无类型常量。