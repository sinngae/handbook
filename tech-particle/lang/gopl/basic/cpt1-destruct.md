# 第一章 程序结构
编程语言中，程序是由大大小小的基础组件构成。
组件由变量赋值、加减法运算复合，基础类型聚合为数组或结构体等数据结构，if/for/switch等控制语句，函数做代码隔离和复用，源文件和包隔离函数。

## 1. 命名
大小写区分；名字必须以一个字母或下划线开头，后面可跟字母、数字、下划线。
关键字25个，如if/else，用于特定语法结构。
30个预定义名字，如int/true，用于内建的常量、类型、函数。
预定义名字可以被程序重新定义，而关键字不行，但仍然不推荐这样做。

函数内部定义，仅函数内可访问；函数外部定义，包内都可访问；函数外部定义（包括函数名）大写字母开头名字，是包导出的，可以被包的外部访问；包内部命名总是用小写字母开头。

惯例，作用域越大，生命周期越长，命名越长。

惯例，优先使用驼峰式命名，即多个单词组成命名，优先使用大小写分隔，而非下划线分隔。
缩略词应当避免大小写混合，如Ascii、Html，应该全大写。

## 2. 声明
Go主要有四种类型的声明语句，var、const、type、func，分别对应变量、常量、类型、函数实体。

Go源文件以.go为文件后缀名。每个源文件由：包声明语句（所属包）、import语句（导入依赖包）、其他（类型、变量、常量、函数等）

## 3. 变量
一般形式：
`var val T = expression`

如果以var val T初始化val，则用零值初始化val。

零值初始化机制:
数值变量对应零值是0，布尔型是false，字符串类型对应的是“”空字符串，接口或引用类型（slice、map、chan和函数）对应的零值是nil。复合类型对应的零值是每一项都是零值。

Go语言的一个声明语句可以声明一组变量，即使不同类型。
Go语言的声明可以用类型，或类型推导。

### 简短变量声明
以`val := expression`声明变量，根据表达式来推导变量。
同事简短声明多个变量应该仅限于局部的可以提高代码可读性的地方使用。

:=是变量声明语句；=是变量赋值操作。
```go
i, j := 0, 1
i, j = j, i
```

简短变量声明的左值，应该至少有一个新的变量，否则编译报错。

### 指针
声明一个指针
```go
var val *T
val := &val0
p := new(T)
```

指针的零值都是nil。

Go语言中，返回函数中局部变量的地址是安全的。
？？？如此使用？会不会使垃圾回收困难？比如层层返回一个局部指针，甚至长期驻留？

&操作取地址，相当于创建了新的别名。
指针的价值在于，我们可以不用名字，而是别名来访问变量。
Go语言的垃圾回收器需要知道变量的全部别名。

标准库flag包中的关键技术即是指针。
flag包用于处理-x/--x格式命令行参数，使用指针指向命令行标志参数变量做别名，用于程序处理。

new(T)创建一个匿名变量，并初始化为T的零值，返回*T。
new(T)同返回局部变量的地址行为相同。

struct{}和[0]int，类型的大小为0，可能地址相同，依赖于具体编译器，其自动垃圾回收器的行为也不同。

### 变量的声明周期
变量的声明周期从创建开始，直到其不再被引用。

函数的小括号里，可以另起一行缩进，但是要满足以(/,/)结束，不然编译器会在行尾自动插入分号导致编译错误。

Go语言的自动垃圾收集器通过每个变量是否可达，判断其是否可以被回收。
所以，一个循环迭代内部的局部变量的生命周期可能超出其作用域，同时，函数内局部变量可以在返回后依然存在（Go语言中称之为逃逸）。
编译器来选择在栈上还是在堆上分配局部变量的存储空间，且不取决与用var还是new声明变量。
逃逸的变量需要额外分配内存，对性能会产生细微的影响。

把局部短生命周期变量的指针保存到长生命周期的对象中，特别是全局变量时，会阻止对其的来及回收，进而影响性能。

## 4. 赋值
Go语言支持+=、++等快捷代码，但++是语句，而不是表达式！！！

### 元组赋值：
允许同时更新多个变量的值。赋值前，先对右值求值，再统一赋给左值。很便利，且代码紧凑。

map查找、类型断言、通道接收，都有一个额外的布尔结果值表示操作是否成功。
```go
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
```

可赋值性也即右值表达式/左值表达式，仅右值表达式可以放赋值语句右边，可以在==等的右边。

## 5. 类型
`type T BaseType`

不同的类型，即使它们的底层类型相同也是不兼容的（不能互相赋值、比较、混在一起运算）。
新命名的类型提供了一个方法T(x)(或(T)(x), 当T是指针类型时)，把x转为T类型，当且仅当两个类型的底层基础类型或指针类型相同时，才允许此转型操作。
一个浮点数转整数，会丢小数部分；把字符串转为[]byte类型slice，会拷贝出一个字符串的副本。
转换函数不会运行时失败，只会编译时失败。

命名类型较多地用于复杂struct类型书写简化。
命名类型还可以为其值定义新的行为，即关联到该类型的函数集合。
命名类型的String方法，会被fmt.Print系列优先使用

## 6. 包和文件
包、文件是为支持模块化、封装、单独编译和代码重用。
一个包所在的目录路径的后缀是包的导入路径（$GOPATH/src后面的部分）。
每个包都对应一个独立的名字空间，不同包的同名变量需要显式使用包名以区分。不同名也不可以省略。
包内大写字母开头的变量是导出的，汉字和日文unicode编码相当于小写字母开头，需要特殊设置。
包级别的名字，在同包的其他源文件中是可以直接访问的，同所有代码在一个文件中。
惯例：包注释的第一句应该先是包的功能概要声明。如果一个包多个包注释，文档工具（go doc）会根据源文件先后顺序链接它们为一个包注释。
惯例：包注释很大，通常会放到一个独立的doc.go文件。

### 包导入
import语句中的字符串对应导入路径，由构建工具解释，默认的工具箱代表一个目录中的一个或多个Go源文件。
源文件中的包名，不要求唯一。
惯例：源文件中的包名，和import语句中的包的导入路径的最后一节目录名相同。
同时导入两个同名包，必须有一个同名包添加别名（原文，重命名）。
导入包，却没有使用，将导致一个编译错误，需要删除或注释掉。

- 工具goimports自动修改import语句。
- 工具gofmt自动格式化代码。
- go env // 查看golang环境变量
- GOROOT：golang的安装路径，安装时确定。
- GOPATH：golang工作路径；bin - 二进制文件路径; pkg - .a文件存放路径；src - go run、go install等命令路径
- GOBIN:go install的存放路径
- go get 下载
- go install会生成可执行文件放到bin目录；编译普通包，生成.a文件放到pkg目录。

### 包的初始化
同包变量先确定依赖顺序，再依次初始化。
构建工具先把.go文件根据文件排序，然后依次调用编译器编译。
包级变量，如果有初始化表达式，则用之。没有的可以用一个特殊的init()函数来简化初始化工作。
每个文件可以包含多个init函数。
init()不能本外部调用，在程序开始执行时，按照它们的声明顺序依次被自动调用。
初始化工作是自下而上的，main包最后被初始化。
init()函数初始化逻辑也可以包装成一个匿名函数处理：
```go
var t T = func() (t T) { t = t0 return }()
```

习题跳过了，未看。

## 7. 作用域
作用域是一个编译时的属性，生命周期是运行时动态的概念，并不相同。
由花括弧包起来的多个语句成为语法块，其内声明的名字无法被外部语法块访问。
全部源代码同属一个全局语法块，包有包的语法块，for/if/switch后的隐式的语法块，switch/select分支语法块，显式书写花括弧里的语法块。
内置的类型、函数、常量是全局作用域的；导入的包的变量作用到该源文件；break/continue/(goto的label)都是函数级别作用域。
可以在不同作用域名字相同，但不可滥用。
编译器对一个名字引用由最内层到全局作用域查找其声明，内层的声明会屏蔽外层的同名声明，使其无法访问。
好的编程风格应该避免这种屏蔽。
声明的顺序不会影响作用域范围，先声明的可以引用其自身或其后的一个声明，完成相互嵌套或递归的类型或函数，但是变量常量不能引用自身。

惯例：Go语言习惯在if中处理错误直接返回，后续正常执行的代码可以不缩进。
注意：短变量声明语句，容易覆盖外层作用域声明的名字，易形成缺陷。
```go
var cwd string
func init() {
	var err error
	cwd, err = os.Getwd();	// 而不是 cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("XXXXXXXXXXXXXXXX %v, %s", err, cwd)
	}
}
```