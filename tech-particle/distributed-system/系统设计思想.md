# 系统设计思想

## 一、高并发
+ 异步并发
    + 异步阻塞调用
    + 异步Future
    + 异步Callback
    + 异步编排Completable Future
    + 请求缓存
    + 请求合并
+ 扩容
  + 单体应用垂直扩容（提升机器性能）
  + 单体应用水平扩容
  + 应用拆分
  + 数据库拆分（水平/垂直）
  + 使用sharding-jdbc，分库分表/读写分离
  + 数据异构
  + 任务系统扩容Elastic-Job
+ 队列
  + 异步处理/系统解耦/数据同步/流量削峰
  + 缓冲队列/任务队列/消息队列/请求队列/数据总线队列
  + Disruptor + Redis队列
  + 基于Canal实现数据异构
+ 应用级缓存
  + 缓存回收策略：空间/容量/时间
  + 缓存回收算法：FIFO/LRU/LFU
  + Java堆/Java堆外/磁盘缓存
  + Guava/Ehcache/MapDB
  + 缓存使用模型：Cache-Aside/Cache-As-SoR/Copy-Pattern
+ http缓存
  + 浏览器缓存
  + HttpClient客户端缓存
  + Nginx代理层缓存
+ 多级缓存
  + 分布式缓存
  + 热点数据与更新缓存
  + 更新缓存与原子性
+ 池化
  + 数据库连接池
  + HttpClient连接池
  + 线程池
### 1.无状态 => 易扩展
实际：应用无状态，配置文件有状态。
### 2.拆分-整合 => 精细化服务治理
1. 系统维度：按照系统功能/业务拆分-整合（中台化？）
2. 功能维度：对一个系统按功能拆分
3. 读写维度：更具读写业务特征进行拆分  
   读请求量大的，使用缓存；写请求量大的，分库分表。聚合读的场景，考虑数据异构拆分系统，或将分散在多处的数据聚在一起存储，以提升性能和可靠性。
4. AOP维度：按访问特征，按AOP进行拆分
5. 模块维度：按照基础后代码维护特征进行拆分
### 3.服务化
进程内服务 -> 单机远程服务 -> 集群手动注册服务 -> 自动注册和发现服务 -> 服务的分组/隔离/路由 -> 服务治理（限流/黑白名单）
### 4.消息队列
用于解耦一些不需要同步调用的服务，或订阅一些自己系统关心的变化。可实现服务解耦（从一对一变为一对多服务）、异步处理、流量销峰/缓冲等。
### 5.数据异构
1. 数据异构  
   订单分库分表一般按订单ID拆分；可按用户ID异构一套，以便查询用户订单。另外，还需要对订单数据进行归档处理，以提升性能和稳定性。
2. 数据闭环  
   如商品详情，数据来源多，影响服务稳定的因素也多。可以异构所有使用的数据，形成数据闭环：
   + 数据异构，通过MQ机制接收数据变更，然后原子化存储到合适的存储引擎，如持久化KV存储如redis。
   + 数据聚合，存储在KV中
   + 前端展示，前端通过依次调用取得所需数据。
  
  数据存储到展示闭环了，部分来源异常时，系统依然可用，只有部分更新积压在MQ或源上。hashtag机制（详见redis）可以将相关数据聚合到一个实例上。
### 6.缓存银弹
浏览器缓存/APP等客户端缓存/CDN缓存/接入层缓存/分布式缓存/应用层缓存/DB缓存

对于兜底数据或异常数据，不应该缓存，否则用户很久才看得到？
### 7.并发化
串行化 => 并行

## 二、高可用
+ 超时与重试
  + 代理层超时与重试
  + Web容器超时与重试
  + 中间件客户端超时与重试
  + 数据库客户端超时与重试
  + Nosql超时与重试
  + 业务超时
  + 前端Ajax超时
+ 回滚
  + 事务回滚
  + 代码库回滚
  + 部署版本回滚
  + 数据版本回滚
  + 静态资源版本回滚
+ 压测与预案
  + 系统压测
    + 压测方案：压测接口/并发量/压测策略/压测指标
    + 压测报告：机器负载/QPS/响应时间/成功率
    + 压测方式：线下/线上压测
    + 读写/仿真/引流/隔离集群/缩容压测
    + 单机/集群/离散/全链路压测
  + 系统优化和容灾
    + 单机调优/架构优化/系统扩容/跨机房容灾
  + 应急预案
    + 网络接入层（DNS/LVS/HaProxy)
    + 应用接入层（Nginx/OpenResty）
    + Web应用层（Tomcat/Gin）
    + 服务层（Dubbo）
    + 数据层（Redis/DB)
  + 监控报警
    + 服务器监控/系统监控/JVM监控/接口监控
    + 报警策略：监控时间段/报警阀值/通知方式
+ 负载均衡
  + 负载均衡算法
  + 失败重试机制
  + 健康检查机制
  + 动态负载均衡
+ 限流
  + 限流算法
  + 应用级限流
  + 分布式限流
  + 接入层限流
+ 降级
  + 降级预案
  + 自动降级/开关降级
  + 读服务/写服务降级
  + 多级降级
  + 配置中心
  + 使用Hystrix降级/熔断
+ 隔离
  + 进程/线程隔离
  + 集群/机房隔离
  + 读写隔离
  + 动静隔离
  + 爬虫/热点隔离
  + 使用Hystrix隔离
  + 基于Servlet3的请求隔离
### 1.降级开关设计（重要）
+ 开关集中化，通过推送服务把开关推送到各应用
+ 可降级的升级读服务，比如只读本地缓存、只读分布式缓存、只读默认降级数据（如库存默认有货）
+ 开关前置化，如架构nginx上可做开关，所有请求或部分请求流量回源到后端应用（回源指域名回源，请求引发的搜索引擎的蜘蛛在爬网中，直接抓取源地址服务上的内容，而不是CDN节点上的缓存内容）。
+ 业务降级，高并发时间段（如电商促销）保障用户下单、支付等核心要求，并保障数据最终一致即可。把其他服务的同步调用改为异步调用，优先处理核心业务请求，保证可用。
### 2.限流
防止恶意请求流量、恶意攻击、或防流量超出系统峰值
1. 恶意请求流量只访问到缓存的数据
2. 对于穿透到后台服务的流量可以用nginx的limit模块处理
3. 对于恶意ip可以使用nginx deny进行屏蔽
原则是限制流量穿透到后端薄弱的应用层。
### 3.切流量
大型应用中的多机房环境中，如果某个机房、机架或者某台服务异常，就要切流量处理（加机器切流量/异地多活互切流量/主备切流量）。
切流量工具：1.DNS，2.HTTP DNS，3.LVS/HaProxy，4.Nginx
### 4.可回滚
版本控制机制：可审计、可追溯、且可回滚。
事务回滚/代码库回滚/部署版本回滚/数据版本回滚/数据版本回滚/静态资源版本回滚。
通过回滚保证系统某些服务场景下的高可用。

## 三、业务设计
### 1.防重入设计
防止重复支付、重复扣减（弱网环境或前端bug导致重复提交）

对于一些重要场景，需要做防重入设计。一般，把一个请求分两步，先提交请求，再确认。提交请求的时候，从服务端获取一个nonceToken（随机数，可以带着用户ID、timestamp等。服务端会把这个nonceToken保存在redis上）；确认请求的时候，先做nonceToken验证（从redis删除该token，如果返回1则继续；返回0，则token不存在，异常退出；），然后处理请求。

需要对redis不可用的场景做降级方案。对于一些可以接受重入的业务，可以临时跳过nonceToken验证。对于完全不可接受冲入的业务，可以在DB做nonceToken的存储。
### 2.幂等设计
幂等操作，任意多次执行所产生的影响均与一次执行的影响相同。
幂等函数/幂等方法，使用相同参数重复执行，并能获得相同结果的函数。
### 3.流程可定义
复用流程系统，提供个性化流程服务。
### 4.状态与状态机
在设计订单交易系统时，会存在正向状态（待付款 -> 待发货 -> 已发货 -> 完成）和逆向状态（取消 -> 退款）等。正向状态与逆向状态应根据系统特征来决定要不要分离存储。状态设计时，应有状态轨迹，方便用户跟踪当前订单的轨迹并记录相关日志，万一出问题时可回溯问题。
### 5.后台系统操作反馈
设计后台系统时，考虑效果的可预览、可反馈。
### 6.后台系统审批化
对于有些重要的后台功能需要设计审批流，比如调整价格，并对操作进行日志记录，从而保证操作可追溯、可审计。
### 7.文档和注释
系统从一开始就建立文档库（设计架构、设计思想、数据字典、业务流程、现有问题等），业务代码和特殊需求的注释。
### 8.备份
成员与代码的备份，代码 -> 代码仓库，成员 -> 结对编程？

## 四、全链路设计
### 1.全局track id生成
distributed id:start_server:next_server[:next_server ...]

## 总结
系统设计（业务实现 + 系统高并发/高可用/高可靠等 + 系统容量规划（流量/容量） + SLA指定（吞吐量/响应时间/可用性/降级方案等）+ 监控报警（机器负载 + 响应时间 + 可用率等）+ 应急预案（容灾/降级/限流/隔离/切流量/可回滚等）。
### 1.高并发原则
缓存/异步并发/连接池/线程池/扩容/消息队列/分布式任务
### 2.高可用原则
+ 通过负载均衡和反向代理实现分流
+ 通过限流保护服务，避免雪崩之灾
+ 通过降级实现部分可用，有损服务
+ 通过隔离实现故障隔离
+ 通过合理设置的超时与重试机制，避免请求堆积造成雪崩
+ 通过回滚机制快速修复错误版本
