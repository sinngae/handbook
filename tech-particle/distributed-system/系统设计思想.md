系统设计思想
---

# 一、高并发
+ 异步并发
    + 异步阻塞调用
    + 异步Future
    + 异步Callback
    + 异步编排Completable Future
    + 请求缓存
    + 请求合并
+ 扩容
  + 单体应用垂直扩容（提升机器性能）
  + 单体应用水平扩容
  + 应用拆分
  + 数据库拆分（水平/垂直）
  + 使用sharding-jdbc，分库分表/读写分离
  + 数据异构
  + 任务系统扩容Elastic-Job
+ 队列
  + 异步处理/系统解耦/数据同步/流量削峰
  + 缓冲队列/任务队列/消息队列/请求队列/数据总线队列
  + Disruptor + Redis队列
  + 基于Canal实现数据异构
+ 应用级缓存
  + 缓存回收策略：空间/容量/时间
  + 缓存回收算法：FIFO/LRU/LFU
  + Java堆/Java堆外/磁盘缓存
  + Guava/Ehcache/MapDB
  + 缓存使用模型：Cache-Aside/Cache-As-SoR/Copy-Pattern
+ http缓存
  + 浏览器缓存
  + HttpClient客户端缓存
  + Nginx代理层缓存
+ 多级缓存
  + 分布式缓存
  + 热点数据与更新缓存
  + 更新缓存与原子性
+ 池化
  + 数据库连接池
  + HttpClient连接池
  + 线程池
## 1.无状态 => 易扩展
实际：应用无状态，配置文件有状态。
## 2.拆分-整合 => 精细化服务治理
1. 系统维度：按照系统功能/业务拆分-整合（中台化？）
2. 功能维度：对一个系统按功能拆分
3. 读写维度：更具读写业务特征进行拆分  
   读请求量大的，使用缓存；写请求量大的，分库分表。聚合读的场景，考虑数据异构拆分系统，或将分散在多处的数据聚在一起存储，以提升性能和可靠性。
4. AOP维度：按访问特征，按AOP进行拆分
5. 模块维度：按照基础后代码维护特征进行拆分
## 3.服务化
进程内服务 -> 单机远程服务 -> 集群手动注册服务 -> 自动注册和发现服务 -> 服务的分组/隔离/路由 -> 服务治理（限流/黑白名单）
## 4.消息队列
用于解耦一些不需要同步调用的服务，或订阅一些自己系统关心的变化。可实现服务解耦（从一对一变为一对多服务）、异步处理、流量销峰/缓冲等。
## 5.数据异构
1. 数据异构  
   订单分库分表一般按订单ID拆分；可按用户ID异构一套，以便查询用户订单。另外，还需要对订单数据进行归档处理，以提升性能和稳定性。
2. 数据闭环  
   如商品详情，数据来源多，影响服务稳定的因素也多。可以异构所有使用的数据，形成数据闭环：
   + 数据异构，通过MQ机制接收数据变更，然后原子化存储到合适的存储引擎，如持久化KV存储如redis。
   + 数据聚合，存储在KV中
   + 前端展示，前端通过依次调用取得所需数据。
  
  数据存储到展示闭环了，部分来源异常时，系统依然可用，只有部分更新积压在MQ或源上。hashtag机制（详见redis）可以将相关数据聚合到一个实例上。
## 6.缓存银弹
浏览器缓存/APP等客户端缓存/CDN缓存/接入层缓存/分布式缓存/应用层缓存/DB缓存

对于兜底数据或异常数据，不应该缓存，否则用户很久才看得到？
## 7.并发化
串行化 => 并行

# 二、高可用
+ 超时与重试
  + 代理层超时与重试
  + Web容器超时与重试
  + 中间件客户端超时与重试
  + 数据库客户端超时与重试
  + Nosql超时与重试
  + 业务超时
  + 前端Ajax超时
+ 回滚
  + 事务回滚
  + 代码库回滚
  + 部署版本回滚
  + 数据版本回滚
  + 静态资源版本回滚
+ 压测与预案
  + 系统压测
    + 压测方案：压测接口/并发量/压测策略/压测指标
    + 压测报告：机器负载/QPS/响应时间/成功率
    + 压测方式：线下/线上压测
    + 读写/仿真/引流/隔离集群/缩容压测
    + 单机/集群/离散/全链路压测
  + 系统优化和容灾
    + 单机调优/架构优化/系统扩容/跨机房容灾
  + 应急预案
    + 网络接入层（DNS/LVS/HaProxy)
    + 应用接入层（Nginx/OpenResty）
    + Web应用层（Tomcat/Gin）
    + 服务层（Dubbo）
    + 数据层（Redis/DB)
  + 监控报警
    + 服务器监控/系统监控/JVM监控/接口监控
    + 报警策略：监控时间段/报警阀值/通知方式
+ 负载均衡
  + 负载均衡算法
  + 失败重试机制
  + 健康检查机制
  + 动态负载均衡
+ 限流
  + 限流算法
  + 应用级限流
  + 分布式限流
  + 接入层限流
+ 降级
  + 降级预案
  + 自动降级/开关降级
  + 读服务/写服务降级
  + 多级降级
  + 配置中心
  + 使用Hystrix降级/熔断
+ 隔离
  + 进程/线程隔离
  + 集群/机房隔离
  + 读写隔离
  + 动静隔离
  + 爬虫/热点隔离
  + 使用Hystrix隔离
  + 基于Servlet3的请求隔离
## 1.降级开关设计（重要）
+ 开关集中化，通过推送服务把开关推送到各应用
+ 可降级的升级读服务，比如只读本地缓存、只读分布式缓存、只读默认降级数据（如库存默认有货）
+ 开关前置化，如架构nginx上可做开关，所有请求或部分请求流量回源到后端应用（回源指域名回源，请求引发的搜索引擎的蜘蛛在爬网中，直接抓取源地址服务上的内容，而不是CDN节点上的缓存内容）。
+ 业务降级，高并发时间段（如电商促销）保障用户下单、支付等核心要求，并保障数据最终一致即可。把其他服务的同步调用改为异步调用，优先处理核心业务请求，保证可用。
## 2.限流
防止恶意请求流量、恶意攻击、或防流量超出系统峰值
1. 恶意请求流量只访问到缓存的数据
2. 对于穿透到后台服务的流量可以用nginx的limit模块处理
3. 对于恶意ip可以使用nginx deny进行屏蔽
原则是限制流量穿透到后端薄弱的应用层。
## 3.切流量
大型应用中的多机房环境中，如果某个机房、机架或者某台服务异常，就要切流量处理（加机器切流量/异地多活互切流量/主备切流量）。
切流量工具：1.DNS，2.HTTP DNS，3.LVS/HaProxy，4.Nginx
## 4.可回滚
版本控制机制：可审计、可追溯、且可回滚。
事务回滚/代码库回滚/部署版本回滚/数据版本回滚/数据版本回滚/静态资源版本回滚。
通过回滚保证系统某些服务场景下的高可用。

# 三、业务设计
## 1.防重入设计
防止重复支付、重复扣减（弱网环境或前端bug导致重复提交）

对于一些重要场景，需要做防重入设计。一般，把一个请求分两步，先提交请求，再确认。提交请求的时候，从服务端获取一个nonceToken（随机数，可以带着用户ID、timestamp等。服务端会把这个nonceToken保存在redis上）；确认请求的时候，先做nonceToken验证（从redis删除该token，如果返回1则继续；返回0，则token不存在，异常退出；），然后处理请求。

需要对redis不可用的场景做降级方案。对于一些可以接受重入的业务，可以临时跳过nonceToken验证。对于完全不可接受冲入的业务，可以在DB做nonceToken的存储。
## 2.幂等设计
幂等操作，任意多次执行所产生的影响均与一次执行的影响相同。
幂等函数/幂等方法，使用相同参数重复执行，并能获得相同结果的函数。
## 3.流程可定义
复用流程系统，提供个性化流程服务。
## 4.状态与状态机
在设计订单交易系统时，会存在正向状态（待付款 -> 待发货 -> 已发货 -> 完成）和逆向状态（取消 -> 退款）等。正向状态与逆向状态应根据系统特征来决定要不要分离存储。状态设计时，应有状态轨迹，方便用户跟踪当前订单的轨迹并记录相关日志，万一出问题时可回溯问题。
## 5.后台系统操作反馈
设计后台系统时，考虑效果的可预览、可反馈。
## 6.后台系统审批化
对于有些重要的后台功能需要设计审批流，比如调整价格，并对操作进行日志记录，从而保证操作可追溯、可审计。
## 7.文档和注释
系统从一开始就建立文档库（设计架构、设计思想、数据字典、业务流程、现有问题等），业务代码和特殊需求的注释。
## 8.备份
成员与代码的备份，代码 -> 代码仓库，成员 -> 结对编程？

# 四、全链路设计
# 1.全局track id生成
distributed id:start_server:next_server[:next_server ...]

# 总结
系统设计（业务实现 + 系统高并发/高可用/高可靠等 + 系统容量规划（流量/容量） + SLA指定（吞吐量/响应时间/可用性/降级方案等）+ 监控报警（机器负载 + 响应时间 + 可用率等）+ 应急预案（容灾/降级/限流/隔离/切流量/可回滚等）。
## 1.高并发原则
缓存/异步并发/连接池/线程池/扩容/消息队列/分布式任务
## 2.高可用原则
+ 通过负载均衡和反向代理实现分流
+ 通过限流保护服务，避免雪崩之灾
+ 通过降级实现部分可用，有损服务
+ 通过隔离实现故障隔离
+ 通过合理设置的超时与重试机制，避免请求堆积造成雪崩
+ 通过回滚机制快速修复错误版本

# 服务设计
优秀的服务设计应该是一个有生命力的环境，客户不是服务的中心，而是服务的一部分。
+ 系统化思考
  + 设计只占10%的工作，还有沟通、流程、人力、客户服务等等
+ 难以复制
  + 只有具体亲自实践，才可能获得最佳实践
+ 行业差异性大
  + 不同的行业差异大
  + 服务升级深层的设计方法论和独特的设计实践创新
  + 结合业务专家共同完成服务体验的设计
+ 综合的复杂的商业问题
+ 设计的过程、思维方式、设计的哲学

## 去客户中心化
+ 以功能为中心 => 以用户为中心 => 以客户为中心
+ 功能设计：以准确输入和准确输出为成功衡量标准
+ 交互设计：在功能完成基础上，加入对用户输入与输出的效能和效率的考量
+ 体验设计：考虑还未发生交互之前，端到端的完整客户体验，去用户化。

**客户绝对不是服务的中心，而是服务的一部分**

环境之中要素有：
+ 物理设施
+ 理念
+ 规则
+ 前台服务者集群（系统和维护人）
+ 后台服务者集群
+ 客户们

更重要的是上述要素之间的关系。

生活中的大部分服务场景都是服从规则优先于个体体验的，特别在公共服务场景中，而且无论如何优化，目的也只是将规则讲解得更透明、设计得更公平，而非关注每个被服务者的个体需求。

## 线性思考
线性思考是服务设计的最大阻碍。

服务设计的网状关系使得你需要考虑更多在传统体验设计中不必重点考虑的东西，例如：
+ 设施和客户：如何让设施表达理念？
+ 理念和客户：如何设置理念让客户和服务者们遵守规则？
+ 前台服务者和客户：如何让前台服务者与客户更好地互动？
+ 后台服务者和客户：如何让后台服务者与前台服务者更好地互动？
+ 规则和客户：如何让客户与设施更好地互动？
+ 客户和客户：如何让客户之间产生互动？

在解决任何一个服务体验的问题时，服务设计需要我们对多个维度进行系统性思考，最终才能产出一个多方都能满意的方案。这是传统以客户为中心、任务流的线性的思考方式所不具备的。

## 服务升级创新
+ 培养良好的设计思维。
  + 设计本身就在朝跨界（Multidisplinary）与融合的方向发展。不要把服务设计当成志向，而是把服务设计背后的设计思维作为志向，在实践中充分应用、不断培养提升大家的设计思维能力。
+ 尝试各种服务，特别是极端情况下的特殊服务。
  + 例如超市的退货、失物招领、酒店换房等等，服务设计真正见功力的地方在于对异常的处理；有机会的话，去东南亚体会酒店、去美国体会零售、去日本体会公众服务，珍惜每一次体验机会，记录下每次接受服务的过程，并尝试用系统的角度去理解为什么这么做。
+ 学会系统性思考。
  + 多了解政治经济领域的复杂问题，培养系统性思考的能力。了解台湾学生为何占领立法院、美国的医保和两党政治有何关联——在我看来，理解了这些就理解了国家作为一个系统运行的基础规律，思维就变得不再极端和狭隘，而更多学会用“上帝视角”来看问题。
+ 对科技敏感。
  + 技术对于服务带来的意义是无穷的可能性，以及对现有解决方案破坏性的创新，认为自己只是创意家提供创意、或者艺术家只会写画、或者战略家只做顶层规划而科技是程序员的事情，这样成不了气候。
+ 对商业模式敏感。
  + 考虑经营性、服务设计的特殊性，服务设计不是写写画画看看广告公司的案例就能完成，需要懂经济，对商业模式有足够的敏感度。