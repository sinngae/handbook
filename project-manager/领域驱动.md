# 领域驱动设计 Domain Drive Design
MVC（Modle - View - Controller）架构里，业务逻辑写在C中会重复、混乱，业务逻辑大都跨M处理，写不到M中，所以要多一层S（Service，MVCS），这是当前主流架构。
M（领域对象）不仅承载数据，也承载一些行为，称作充血模型；仅承载数据和一些getter/setter方法，称为贫血模型。
贫血模型的S层会退化为面向功能的开发活动，耦合多，内聚少；充血模型可以把业务逻辑封装在领域模型里，但封装的层次很难维护，批量类业务逻辑也不好实现。
主流架构一般把业务逻辑封装在Service层，M层承载数据结构。
哲学里，一般把操作的主体和客体分类，世界由客体（实体）组成，主体（观察者）感知或假定客体作为实体存在。正确的面向对象，应该把主体做“拟人化”，对客体做“拟物化”。主体感知也是改造客体的过程。领域模型是客体，领域服务是主体，应用程序的本质是认知世界


领域驱动是用于设计的，而不是用于需求分析。
项目管理中使用领域驱动设计？

## 域驱动的目标
将项目的主要重点放在核心领域和领域逻辑上；
根据领域模型建立复杂的设计；
启动技术专家和领域专家之间的创造性合作，以迭代方式完善解决特定领域问题的概念模型。

## 概念 Concepts
### 上下文 （语境？情景）context
用来确定其含义的单词或陈述的设置；
（当一个词语或语句新出现时）用于确定一个词语或语句的一系列设定（前置条件）。
### 域 domain
影响、活动（本体是一个知识领域）。软件上的领域是用户使用程序所在的主题区域（程序用于做什么？）。
### 模型 model
用于描述domain的某些方面的一系列抽象，用于解决与domain相关的问题。
### 通用语言 ubiquitous
一种围绕领域模型构建的语言，所有团队成员都使用该语言将团队的所有活动与软件联系起来。

## 领域驱动的设计策略 Strategic Design
理想情况下，最好有一个统一的模型。尽管这是一个崇高的目标，但实际上，它通常分为多个模型。生活中，认识到这个事实并实践是很有用的。
设计策略是维护模型完整性、提取域模型、使用多个模型的一组原则。

### 有界的上下文 Bouned Context
大型项目大都使用多种模型。但是，当将基于不同模型的代码组合在一起时，软件将变得漏洞百出、不可靠且难以理解。团队成员之间的沟通变得混乱、令人迷惑。通常不清楚一个模型不该应用在哪些情景中，模型乱象现象。

因此：显式地定义模型适用的情景。显式地给团队组织、应用程序特定部分的用法、代码库、数据库等物理存在设置边界。在这边界内，保持模型严格一致，而不是因内部和外部的问题而分神或困惑。

### 持续集成 Continuous Integration
一定数量的人群在相同的有界上下文中工作时，模型非常容易分裂（分叉？歧义）成多个。团队越大，问题就越大，但是只有三到四个人会遇到严重的问题。然而，系统分解为太小的情景，集成和一致性的价值也越小。

因此：建设频繁合并所有代码等其他人造品的流程，并使用自动测试来快速标记碎片。随着概念在人们的脑海中不断发展，请不懈地运用共同语言来敲定模型的共享视角。

### 上下文图 Context Map （全局视图）
在没有全局视图的情况下，单个有界上下文会带来一些问题。其他模型的上下文可能仍然含糊不清且不断变化。
其他团队的人员不会非常了解上下文范围，并且会在不知不觉中进行更改，从而模糊边缘或使交互复杂化。当必须在不同情景之间建立联系时，它们往往会相互渗入。

因此：确定项目中正在使用的每个模型并定义其有界的上下文。这包括非面向对象子系统的隐式模型。为每个有界上下文命名，并把该名称作为通用语言的一部分。描述模型之间的联系点，概述任何通信的显式翻译并强调任何共享。绘制现有地形。

## 建材 Building Blocks
在 “领域驱动的设计” 一书中，阐述了许多高级概念和实践，例如共同语言，这意味着领域模型应形成领域专家给出的用于描述系统需求的通用语言，并且同样有效适用于业务用户或赞助商以及软件开发人员。这本书非常着重于将域层描述为多层体系结构的面向对象系统中的常见层之一。
DDD中用于表达、创建和检索域模型的人造品：

### 实体 Entity
一个不由其属性定义的对象，而是由一贯的连续性及其身份标识定义的对象。
示例：大多数航空公司在每个航班上都唯一地区分每个座位。在这种情况下，每个席位都是一个实体。但是，西南航空，EasyJet和Ryanair并不区分每个座位。所有座位都一样。在这种情况下，席位实际上是价值对象。
### 价值对象 Value Object
包含属性但没有概念标识的对象。他们应该被视为一成不变的。
示例：人们交换名片时，通常不会区分每张唯一的名片；他们只关心卡上打印的信息。在这种情况下，名片是价值对象。
### 聚合 Aggregate
由根实体（也称为聚合根）绑定在一起的对象的集合。聚合根通过禁止外部对象保留对其成员的引用来确保聚合中所做更改的一致性。
例如：驾驶汽车时，您不必担心车轮向前移动、发动机里点火和烧油等。您只是在开车。在这种情况下，汽车是其他几个对象的集合，并充当所有其他系统的集合根。
### 域事件 Domain Event
定义事件（发生的事情）的域对象。域事件是域专家关心的事件。
### 服务 Service
当一个操作在概念上不属于任何对象时。遵循问题的自然轮廓，可以在服务中实施这些操作。另请参见服务（系统架构）。
### 仓库 Reposiory
**检索域对象的方法**应委派给专门的存储库对象，以便可以轻松交换备用存储实现。
### 厂 Factory
**用于创建域对象的方法**应委托给专门的Factory对象，以便可以轻松互换替代实现。

## 命令查询分析 Command-Query Separation CQR / CQRS（职责分离）
命令查询分离（CQS）是命令式计算机编程的一个原则。它是由Bertrand Meyer设计在Eiffel编程语言方面的开创的。CQS：每个方法都应该是执行操作的命令，或者是将数据返回给调用方的查询，但不能同时是两者（提出问题不应改变答案）。更正式地讲，方法仅在它们是参照透明的且因此没有副作用的情况下才应返回值。（联想一下接口幂等性设计）

### 与契约式编程的联系
命令查询分离特别适合契约式编程设计（DbC），其中程序的设计表示为嵌入在源代码中的断言，描述了某些关键时刻的程序状态。在DbC中，断言被视为设计注释，而不是程序逻辑，因此，它们的执行不应影响程序状态。CQS对DbC有利，因为任何断言都可以调用任何返回值的方法（任何查询），而不必担心修改程序状态。

从理论上讲，这建立了一种合理性的度量标准，使人们可以推理程序的状态而无需同时修改该状态。实际上，CQS允许在工作系统中绕过所有断言检查，以提高其性能，而不会无意间更改其行为。CQS还可以防止某些类型的heisenbug（海森bug，探针效应，使用测试探针时，会改变客体的行为）的发生。


## 缺点
为了帮助将模型保持为纯净而有用的语言构造，团队通常必须在域模型内实现大量的隔离和封装。因此，基于域驱动设计的系统的成本可能相对较高。虽然域驱动的设计提供了许多技术优势（例如可维护性），但是Microsoft建议仅将其应用于复杂领域，模型和语言处理在复杂信息交流、领域共识的构建方面具有明显优势。

## 六边形 Hexagon
MVC -> MVCS/MVVC -> 六边形
model+viewer+controller -> service+/viewmodel+ -> 以domain+service为核心，数据库/

传统架构的可测试问题：1.服务不方便自动化测试、单元测试，而且这些是最细节、最易变的，进而测试覆盖率也高不了；2.服务依赖具体的输入输出端口，而缺少一个通用的输入输出层；3.测试服务之间交互困难，全链路的测试覆盖几乎做不到；。

传统架构的开发问题：1.业务逻辑很容易跨层编写（层的边界不清晰）；2.单一维度架构不能构架更复杂的应用。

接口的问题：接口可以指UI接口，这个接口后面的逻辑可能非常大、非常复杂；也可以指具体的函数，这个接口，可以是非常小的。测试的主体应该是明确的，是端口和适配器。

目标：1.服务的每个功能都是一个API，自动化测试、单元测试监测代码的改动是否破坏已有的功能；2.自动化测试监测代码是否完成预期的功能；3.其他服务以headless模式部署、交互；4.服务只关心业务，设计过程也容易；5.回归测试可以直接监测到发生点。

六边形并不是指有六个层次或六个什么，而是多个端口和适配器。一个端口对内对应一组交互行为，对外对应一组适配器，适配器可以是HTTP接口、图形用户界面、mock数据库、真实数据库、其他服务、测试套件等。端口一般可分为用户端口和数据端口。不用拘泥于端口的数量，一般倾向于选择更少的端口，依赖于具体对分层模型的界定。

### 端口适配器模式
外部事件被相应的适配器转化成合适的过程调用或消息给应用；应用把要输出的内容或消息传递给适配器，适配器把它们转成合适的信号。应用不应该关注输入设备，而只与适配器交互。这种设计模式是为了解耦端口和应用，也是为了解耦技术和业务。
第三方服务/接口协议等使用适配器，采用依赖注入。
应用可以通过用户、程序、自动化测试、批处理脚本来驱动，独立于最终的运行环境及数据库进行开发和测试。

### 结构
支持几种运行测试场景
1.使用测试套件驱动应用，用mock的内存数据库模拟真实数据库。
2.自动化测试脚本，带有测试数据的真实数据库。
3.生产环境，真实数据库。

如何mock数据库？
1.使用mock接口mock数据；
2.使用嵌入式数据库mock数据库服务；

## ERD 实体关系图
概念数据模型/逻辑数据模型/物理数据模型
不必拘泥于UML手法，描绘地清楚明确即可。

数据流图DFD把系统中的信息流可视化呈现，数据存储+参与者+过程
